{"meta":{"title":"空欢","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"读书","date":"2019-10-01T05:07:01.805Z","updated":"2019-10-01T05:07:01.805Z","comments":true,"path":"reading/index.html","permalink":"http://yoursite.com/reading/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-10-16T16:30:33.000Z","updated":"2019-10-16T16:31:34.716Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-10-08T15:59:23.150Z","updated":"2019-10-08T15:59:23.150Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Welcome My Blog 勤奋好学、品学兼优、乐观向上、爱好广泛、尊敬师长、团结同学、做事执着、有毅力、是一个德、智、体、美、劳全面发展的好学生。我有一颗善良真诚的心灵。有人说，金子是最纯美的，但比金子更美的是人的心灵。我有一颗洁白无暇、善良真诚的心灵，我心地善良、追求纯真、无私无邪。在家里，对待亲人，关注亲人的冷暖，经常帮助爸爸妈妈做一些力所能及的家务活，打扫卫生，让亲情其乐融融。在学校，我有一颗真诚的爱心。对于困难同学，我总是乐于伸出援助的小手，助人为乐，真诚奉献，对于学习上的后进生，我也是及时给予力所能及的帮助，从不计较个人的得失。"}],"posts":[{"title":"随记","slug":"随记","date":"2019-12-25T15:19:47.000Z","updated":"2019-12-25T15:20:36.624Z","comments":true,"path":"2019/12/25/随记/","link":"","permalink":"http://yoursite.com/2019/12/25/随记/","excerpt":"","text":"H5相关 1234567891011121314&gt; - 语义化标签[header,nav,main,section,aside,articel,footer]--有利于SEO,易读,便于开发与维护&gt; - 自定义属性,标签本身不带的属性,JS中可以通过dataset[属性名]来获取到&gt; - 表单新特性 : calendar,date,time,email,url,search,tel,file,number&gt; - 多媒体视频(video)和音频(audio)&gt; - web存储 : (都只能存储字符串)&gt; sessionStorage : 关闭浏览器清空数据,大小5M&gt; localStorage1 : 永久有效,大小20M,多窗口都可使用&gt; - canvas : 画布&gt; - webworker : 多线程,一旦建立四种运行,不被主线程打断,同源限制,dom限制,没有window,parent,document对象&gt; - webscoket : 客户端和服务端都可以主动的推送消息，可以是文本也可以是二进制数据(不会产生跨域),&gt; 协议的标识符就是ws。像https一样如果加密的话就是wxs。&gt; - 拖拽api : dragstart开始,drag过程中,dragend结束&gt; - 地理API&gt; C3相关 1234567891011121314&gt; - 选择器 : 属性选择器E[attr],伪类选择器E:nth-child(n),空伪类E:empty ,排除伪类E:not(selector)&gt; - 颜色 : 新增rgba与hsla模式&gt; - 文本 : 文本阴影,text-shadow,设置偏移量h-shadow&amp;v-shadow,模糊度blur,颜色(可设置透明度)color&gt; - 盒模型 : box-sizing:border-box&gt; - 边框 : 圆角border-radius,阴影box-shadow&gt; - 背景 : background-size尺寸;background-origin定位参照原点;background-clip裁切&gt; - 渐变 : linear-gradient线性;radial-gradient径向&gt; - 2D转换 : trandlate位移;scale缩放;rotale旋转;transform-origin转换元素原点&gt; - 3D转换 : perspective透视;transform-style:persevere-3d给父元素设置转3D立体;backface-visibility:hidden背景可见&gt; - 动画 : @keyframes定义;百分比编写;animation将动画应用于相对元素&gt; - 媒体查询 : @media screen and (宽高)&#123;...&#125;&gt; - 字体图标 : font-face&gt; - 弹性布局 : flex&gt; ES6 12345678910111213141516171819202122232425262728293031&gt; - 变量声明 : 暂时性死区&gt; a. let-块级作用域,声明便令,先声明后用,同块不可重复声明,无变量提升 &gt; b. const-块级作用域,声明常量,声明即赋值,否则报错,不可重新赋值&gt; - 解构赋值 : let&#123;a&#125;=&#123;a:5&#125;,对象通过键名对应,数组通过索引对应&gt; - 模板字符串 : 支持换行,插入变量使用'$&#123;&#125;'&gt; - 函数扩展 : 箭头函数,内部没有this,没有arguments&gt; - 参数默认值 : function printText(text = 'default') &#123;console.log(text);&#125;&gt; - Spread : 展开运算符,将对象或数组分解为一个一个元素&gt; - Rest : 放在形参末尾,接收剩余参数为数组&gt; - class类的概念,通过extends继承父类,通过super继承父类构造函数与普通函数&gt; - for of 与for in 前者用于遍历迭代器,后者用于遍历对象属性&gt; - 模块化 : import XXX from \"XXX\"导入;export default XXX导出&gt; - 数据结构&gt; a. set : 类似于数组,值都是唯一的&gt; b. weakSet : 成员只能是对象,里面的引用,都不计入垃圾回收机制,不可遍历,没有size&gt; c. map : 类似于对象,也是键值对集合,但是键名的范围不局限在字符串&gt; d. weakMap : 类似于map.只接受对象作为键名(除null),里面的引用都不计入垃圾回收机制,不可遍历,没有size&gt; - Array.from() : 非数组转数组(有length,可遍历的类似数组)&gt; - Array.of() : 将一组值转换为数组&gt; - 数组方法 : &gt; a. copyWithin() : 将指定位置成员复制到其他位置,会覆盖原有成员,然后返回当前数组,会修改当前数组&gt; b. find() 和 findIndex() 返回符合条件的数组成员,无则undefined&gt; c. fill() : 填充数组,(元素,开始位置,结束位置)&gt; d. entries()，keys() 和 values() : 遍历数组,返回一个遍历器对象,可用for of变量,对键值对,键,值的遍历&gt; e. includes() : Array.prototype.includes返回布尔,表示是否包含给定的值,类似字符串includes方法&gt; - 字符串方法 :&gt; a. includes()：返回布尔值，表示是否找到了参数字符串。&gt; b. startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。&gt; c. endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。&gt; d. repeat() : 重复原字符串n次&gt; 减少页面加载时间 123456&gt; 1. 懒加载&gt; 2. 减少重复的http请求&gt; 3. 服务器开启gzip压缩&gt; 4. 压缩合并js，css代码&gt; 5. 应用精灵图&gt; 渐进增强和优雅降级 123&gt; 1. 渐进增强是从低级的现状开始，然后不断添加完善功能&gt; 2. 优雅降级是从比较完整的现状开始，然后向下兼容&gt; web应用从服务器主动推到Data到客户端 1234567&gt; 1. html5 websocket&gt; 2. WebSocket 通过 Flash&gt; 3. XHR长时间连接&gt; 4. XHR Multipart Streaming&gt; 5. 不可见的Iframe&gt; 6. script标签的长时间连接(可跨域)&gt; jsonp的原理，优缺点 1234567&gt; 1. json是对象简谱，是一种数据格式&gt; 2. jsonp是json的一种“使用模式”,可用于解决主流浏览器的跨域数据访问的问题&gt; 原理：所有主流浏览器出于安全因素考虑都有同源策略，而HTML中的script标签则不受此限制，jsonp的本质是利用script标签的src属性进行跨域请求&gt; 优点：不受同源限制&gt; 缺点：只能用于get请求，不能用于post请求 &gt; 补充 : jsonp调用方页面上使用script标签引用第三方API地址；第三方响应的数据是JSON数据的包装（callback（&#123;&#125;）），其中函数的实参是json对象，可以再callback函数中进行数据处理。&gt; javaScript同源策略 123456&gt; 协议，域名，端口号&gt; &gt; 同源策略 是由NetScape提出的一个著名的安全策略。所谓的同源，指的是协议，域名，端口相同。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。&gt; &gt; 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。&gt; js请求有哪些地方会有缓存处理 12345&gt; 1. DNS缓存 : 短时间内多次访问某个网站，在限定时间内，不用多次访问DNS服务器。&gt; 2. CDN缓存 : 内容分发网络（人们可以在就近的代售点取火车票了，不用非得到火车站去排队）&gt; 3. 浏览器缓存 : 浏览器在用户磁盘上，对最新请求过的文档进行了存储。&gt; 4. 服务器缓存 : 将需要频繁访问的Web页面和对象保存在离用户更近的系统中，当再次访问这些对象的时候加快了速度。&gt; typeof和instanceof区别 123&gt; 1. 判断一个变量的类型可以用typeof,检测数据类型&gt; 2. instanceof用于判断某个对象是否被另一个函数构造&gt; 返回null，undefind,二者区别 1234567891011121314&gt; 1. null是js中的关键字，表示空值，null可以看作是object的一个特殊的值，如果一个object值为空，表示这个对象不是有效对象；&gt; 2. undefined不是js中的关键字，其是一个全局变量，是Global的一个属性，以下情况会返回undefined:&gt; a. 声明但是没有赋值的变量的值为undefined&gt; b. 使用不存在的属性的返回值是undefined&gt; c. 调用没有返回值的函数，返回值也是undefined&gt; e. 调用函数时，该提供的参数没有提供&gt; 区别 : &gt; a. 类型不一样；&gt; b. 转化为值时不一样：undefined为NaN ,null为0； &gt; c. undefined===null;//false undefined==null;//true&gt; e. isNaN(null)//false isNaN(undefined)//true&gt; f. typeof null//object typeof undefined//undefined&gt; 备注：null当使用完一个比较大的对象时，需要对其进行释放内存时，设置为null&gt; 多图片优化 12345&gt; 1. 精灵图&gt; 2. 懒加载&gt; 3. 预加载-幻灯片之类的使用,将当前展示图片的前一张和后一张优先下载&gt; 4. 使用特殊编码的图片。&gt; 变量提升和函数提升有什么区别 12345678&gt; 1. 所有的声明都会提升到作用域的最顶上去&gt; 2. 同一个变量只会声明一次，其他的会被忽略掉&gt; 3. 函数声明的优先级高于变量申明的优先级，并且函数声明和函数定义的部分一起被提升&gt; 注意 : &gt; a. 只有声明本身会被提升，而赋值操作不会被提升。&gt; b. 变量会提升到其所在函数的最上面，而不是整个程序的最上面&gt; c. 函数声明会被提升，但函数表达式不会被提升。&gt; 安卓手机边框圆角会失效，解决方案 12345&gt; 安卓部分低版本系统，不支持border-radius:50%;的写法&gt; 1. 设置border：none; 去掉边框&gt; 2. 设置border-radius:40px; 若遇到浏览器兼容的?问题，可加上兼容的css代码&gt; 3. 最后，使用box-shadow: 0px 0px 5px #ccc; 利用该特性设置边框&gt; innerText火狐不可以用 123&gt; 1. firefox改成了textContent方法/属性，Firefox中文本中间的空白字符被替换了；&gt; 2. 使用obj.innerText提取文本&gt; ie8在png格式的图片不能显示 12345&gt; 方法一 : 重新注册pngfilt.dll文件。&gt; 方法二 : 注册表中“Internet Settings”值被更改&gt; 方法三 : 改注册表中“MIME”项&gt; 原因 :其他软件（如quicktime）安装时，替换了windows原有的Pngfilt.dll文件，导致pngfilt.dll加载不成功。&gt; 阻止事件冒泡 123&gt; IE : e.cancelBubble = true&gt; w3c : e.stopPropagation()&gt; 阻止某个事件的默认行为 12345678910&gt; w3c方法是e.preventDefault;&gt; IE中方法是window.event.returnValue = false;&gt; (首先对事件冒泡和默认行为以及要用到的事件对象event有个认识&gt; 对事件冒泡的理解是当触发一个子元素的事件时，同时它的父元素的事件也会依次被触发。即事件从最低层元素依次向最外层元素触发&gt; 默认事件（行为）指的是有些元素自身会有一些行为会自行被触发。例如&lt; a&gt;链接，提交按钮&lt; input type = ‘submit’/&gt;&gt; event代表事件的状态。例如触发event对象的元素、鼠标的位置及状态，按下的键等等&gt; event只在事件发生的过程中才有效&gt; 不同的浏览器用到event时会有所不同：例如IE里面是全局变量，即window.event；而火狐firefox里面是临时变量，需要用参数引导才可以用)&gt; javaScript的return只会阻止默认行为，而jQuery的return false两者都会阻止。&gt; 闭包,场景 “闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。”1.模仿块级作用域，避免全局污染；2.储存变量，闭包的另一个特点是可以保存外部函数的变量，内部函数保留了对外部函数的活动变量的引用，所以变量不会被释放。3.封装私有变量，把函数当作一个范围，函数内部的变量就是私有变量，在外部无法引用，但是我们可以通过闭包的特点来访问私有变量。 xhr对象在IE和火狐中的创建方式 IE中通过new ActiveXObject()得到Firefox中通过new XMLHttpRequest()得到 ajax和js的区别 123456&gt; 1. AJAX就是“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。&gt; 2. 它不是一种语言，它算是一个多种语言共同协助的一个技术。&gt; 3. Ajax主要用于创建快速动态网页的技术。&gt; 4. Javascript是一个开发语言，在使用ajax技术中，需要使用到它&gt; 二者区别 : ajax是一种多技术的综合使用（其中包含了javascript），javascript只是一种脚本语言&gt; ajax一共有几种callback 八种：​ onSuccess；​ onFailure；​ onUninitialized；​ onLoading；​ onLoaded；​ onInteractive；​ onComplete；​ onException。 ajax接受到的数据类型及处理 String,JSON串,JSON对象xhr常用的方法和属性 : 1) open( ) -方法 作用：创建请求 语法：open(“method”,”url”,isAsyn) ① method 请求方式：POST或GET ② url 请求地址 ③ isAsyn 使用 同步(false) 还是 异步(true) 的方式发送请求​ 2）readyState - 属性​ 作用：​ 0：请求发送还未发送 ①已经打开到WEB服务器的连接 ②xhr对象已经接受响应消息的头部 ③xhr对象已经接受响应消息的主体 ④xhr已经接受完成响应消息​ 注意：当readyState为4的时候，表示所有的响应消息都接受完毕​ 3）status -属性​ 作用：表示服务器相应状态码​ 1消息​ 2成功​ 3重定向​ 4请求错误​ 5服务器错误​ 值： 200 正常接受请求以及给出响应​ 403 拒绝访问​ 401 当前请求需要用户验证 404 要请求的资源不存在 500 服务器内部错误​ 注意：当status值是200的时候​ 4）onreadystatechange - 事件​ 当xhr的readyState发生改变时，要自动激发的操作。用于监听readyState状态改变的​ xhr.onreadystatechange=function(){​ //每当readyState状态码发生改变的时候要执行的操作​ if(xhr.readyState==4 &amp;&amp; xhr.status==200){​ //当xhr已经完全接收响应了，并且服务器也正常给出响应的时候要做的事​ var txt=xhr.responseText;//服务器端响应回来的数据​ }​ }​ 5）send( ) -方法​ 作用：发送请求​ 语法：xhr.send(body);​ body：发送的请求数据。如果是get提交方式，此处为null；如果是post提交方式，此处就是提交的数据 取消移动页面缩放 12&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0\" /&gt;&gt; 三次握手，为什么不用一次 12&gt; 只一次的话，服务器没有回复，肯定不行，两次的话，如果因为某种情况（像是网络不好等）导致客户端没有收到服务端的回复，之后客户端发新请求收到正常回复，但是之前没收到的失效回复服务端不知道它已经失效，会一直为他委会着资源，这就造成了资源的浪费。&gt; loader，plugin的区别 123&gt; 1. loader主要用于数据的格式转换&gt; 2. plugin非常强大可以处理包括loader在内的很多事情，常用于导入插件&gt; rem根标签是如何计算的 123456&gt; rem是指根元素（root element，html）的字体大小，从遥远的 IE6 到版本到 Chrome 他们都约好了，根元素默认的 font-size 都是 16px。&gt; rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小；&gt; 所以1rem16(这个是html的fontsize)=16px;&gt; 2rem16=32px;&gt; 要想让rem和px成100倍的关系，即1rem*100=100px；则html的字体大小就应该是100px；&gt; vuex常用的方法 1234567891011&gt; VueX 是一个专门为 Vue.js 应用设计的状态管理构架，统一管理和维护各个vue组件的可变化状态(你可以理解成 vue 组件里的某些 data )。&gt; &gt; Vuex有五个核心概念：&gt; state, getters, mutations, actions, modules。&gt; 1. state：vuex的基本数据，用来存储变量&gt; 2. geeter：从基本数据(state)派生的数据，相当于state的计算属性&gt; 3. mutation：提交更新数据的方法，必须是同步的(如果需要异步使用action)。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。&gt; 回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。&gt; 4. action：和mutation的功能大致相同，不同之处在于 ==》1. Action 提交的是 mutation，而不是直接变更状态。 2. Action 可以包含任意异步操作。&gt; 5. modules：模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。&gt; 实现图片懒加载 1234567&gt; 首先先自定义属性如:data-imgurl,存放着图片的路径，然后通过js判断界面滚动的位置/图片是否已加载，&gt; 未加载再去获取属性data-imgurl的值赋给src &gt; 1. 加载loading图片&gt; 2. 判断哪些图片要加载【重点】&gt; 3. 隐形加载图片&gt; 4. 替换真图片&gt; 伪类与伪元素 123&gt; 伪类-:active :hover :link :visited :first-child :enable :disable :checked :target :nth-child(n) :last-child :empty&gt; 伪元素-::before ::after ::first-letter ::first-line ::selection&gt; pop，push，unshift，shift区别 依次为数组尾部删除，尾部添加，首部添加，首部删除 webpack打包后调试 123&gt; 配置开发环境 devtool：'source-map'&gt; source-map会为每一个打包后的模块生成独立的soucemap .map , 会在 bundle 文件末尾追加 sourceURI= 指定 .map 文件路径，会在浏览器开发者工具中看到webpack://的文件夹&gt; 快速排序和冒泡排序的区别 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt; 时间复杂度不同，即运行算法的性能不同，数据越多越复杂，快速排序的优势越大。&gt; 快排的时间复杂度：nlogn，冒泡：n2&gt; ******************************************************************&gt; 快排 :&gt; var arr = [5,4,6,8,9,7,1,2,3,4,5]&gt; function quickSort(arr)&#123;&gt; if(arr.length&lt;1)&#123;&gt; return arr&gt; &#125;&gt; var left = []&gt; var right = []&gt; &gt; var index = Math.floor(arr.length/2)&gt; var item = arr.splice(index,1)[0]&gt; &gt; for(var i = 0 ; i &lt; arr.length ; i++)&#123;&gt; if(arr[i]&lt;item)&#123;&gt; left.push(arr[i])&gt; &#125;else&#123;&gt; right.push(arr[i])&gt; &#125;&gt; &#125;&gt; return quickSort(left).concat([item],quickSort(right))&gt; &#125;&gt; let a = quickSort(arr)&gt; console.log(a);&gt; &gt; ******************************************************************&gt; 冒泡 :&gt; var arr = [1,321,561,2,31,56,23,10,61,23,2,31,60,230,23,] &gt; var bubbling = function(arr)&#123; // 冒泡&gt; let len = arr.length// 取出长度&gt; for(var i = 0 ; i &lt; len-1 ; i++)&#123;// 遍历&gt; for(var j = 0 ; j &lt; len-i-1 ; j++)&#123;// 遍历&gt; if(arr[j]&lt;arr[j+1])&#123; // 判断&gt; let temp = arr[j] // 取值&gt; arr[j] = arr[j+1] // 交换&gt; arr[j+1] = temp&gt; &#125;&gt; &#125;&gt; &#125;&gt; return arr // 返回&gt; &#125;&gt; console.log(bubbling(arr))&gt; 手写深拷贝&amp;浅拷贝深拷贝 1234567891011121314151617181920212223242526272829303132333435363738&gt; var obj1 = [&#123;&gt; name: '臧三',&gt; childs: ['小明', '小芳']&gt; &#125;]&gt; **************************************************************&gt; 利用json.stringify&gt; var obj2 = JSON.parse(JSON.stringify(obj1))&gt; obj2[0].childs = []&gt; console.log(obj1, obj2)&gt; **************************************************************&gt; 利用递归来实现一个方法进行拷贝&gt; var obj3 = function(data)&#123; &gt; if (typeof data === 'object' &amp;&amp; data) &#123;&gt; let val = typeof data.length === 'number' ? [] : &#123;&#125;&gt; for(let i in data) &#123;&gt; val[i] = obj3(data[i])&gt; &#125;&gt; return val&gt; &#125; else &#123;&gt; return data&gt; &#125;&gt; &#125; &gt; **************************************************************&gt; 利用instanceOf&gt; function copy(newObj,obj)&#123;&gt; for(let key in obj)&#123;&gt; if( obj[key] instanceof Array)&#123;&gt; newObj[key] = []&gt; copy(newObj[key],obj[key])&gt; &#125;else if(obj[key] instanceof Object)&#123;&gt; newObj[key] = &#123;&#125;&gt; copy(newObj[key],obj[key])&gt; &#125;else&#123;&gt; newObj[key]=obj[key]&gt; &#125;&gt; &#125;&gt; &#125;&gt; 浅拷贝 123456789101112&gt; 1. 利用Object.assign()&gt; var obj1 = &#123;a: 1, b: 2&#125;&gt; var obj2 = Object.assign(&#123;&#125;, obj1)&gt; obj2.a = 4&gt; console.log(obj1, obj2)&gt; &gt; 2. 利用解构赋值&gt; var obj1 = &#123;a: 1, b: 2&#125;&gt; var obj2 = &#123;...obj1&#125;&gt; obj2.a = 4&gt; console.log(obj1, obj2)&gt; 区别 123&gt; 深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用，&gt; 深拷贝在计算机中开辟了一块内存地址用于存放复制的对象，而浅拷贝仅仅是指向被拷贝的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变。&gt; 块级元素和行内元素区别块级元素 1234567891011121314151617181920212223242526272829303132333435363738&gt; 每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素；&gt; &gt; 块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如&lt;form&gt;只能包含块级元素。其他的块级元素则可以包含 行级元素如&lt;P&gt;.也有一些则既可以包含块级，也可以包含行级元素。&gt; &gt; DIV 是最常用的块级元素，元素样式的display:block都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。&gt; &gt; 特点 :&gt; ①、总是在新行上开始；&gt; ②、高度，行高以及外边距和内边距都可控制；&gt; ③、宽度缺省是它的容器的100%，除非设定一个宽度。&gt; ④、它可以容纳内联元素和其他块元素&gt; &gt; 常见块级元素 :&gt; address – 地址&gt; blockquote – 块引用&gt; center – 举中对齐块&gt; dir – 目录列表&gt; div – 常用块级容易，也是CSS layout的主要标签&gt; dl – 定义列表&gt; fieldset – form控制组&gt; form – 交互表单&gt; h1 – 大标题&gt; h2 – 副标题&gt; h3 – 3级标题&gt; h4 – 4级标题&gt; h5 – 5级标题&gt; h6 – 6级标题&gt; hr – 水平分隔线&gt; isindex – input prompt&gt; menu – 菜单列表&gt; noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容&gt; noscript – 可选脚本内容（对于不支持script的浏览器显示此内容）&gt; ol – 有序表单&gt; p – 段落&gt; pre – 格式化文本&gt; table – 表格&gt; ul – 无序列表&gt; 行内元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&gt; 也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 SPAN 元素，IFRAME元素和元素样式的display : inline的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。&gt; &gt; 特点 :&gt; ①、和其他元素都在一行上；&gt; ②、高，行高及外边距和内边距不可改变；&gt; ③、宽度就是它的文字或图片的宽度，不可改变&gt; ④、内联元素只能容纳文本或者其他内联元素&gt; &gt; 注意 :&gt; 设置宽度width 无效。&gt; 设置高度height 无效，可以通过line-height来设置。&gt; 设置margin 只有左右margin有效，上下无效。&gt; 设置padding 只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。&gt; &gt; 常见行内元素 :&gt; a – 锚点&gt; abbr – 缩写&gt; acronym – 首字&gt; b – 粗体(不推荐)&gt; bdo – bidi override&gt; big – 大字体&gt; br – 换行&gt; cite – 引用&gt; code – 计算机代码(在引用源码的时候需要)&gt; dfn – 定义字段&gt; em – 强调&gt; font – 字体设定(不推荐)&gt; i – 斜体&gt; img – 图片&gt; input – 输入框&gt; kbd – 定义键盘文本&gt; label – 表格标签&gt; q – 短引用&gt; s – 中划线(不推荐)&gt; samp – 定义范例计算机代码&gt; select – 项目选择&gt; small – 小字体文本&gt; span – 常用内联容器，定义文本内区块&gt; strike – 中划线&gt; strong – 粗体强调&gt; sub – 下标&gt; sup – 上标&gt; textarea – 多行文本输入框&gt; tt – 电传文本&gt; u – 下划线&gt; 区别 12345678910111213141516171819202122&gt; 区别一：&gt; &gt; 块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度&gt; 行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。&gt; &gt; 区别二：&gt; &gt; 块级：块级元素可以设置宽高&gt; 行内：行内元素不可以设置宽高&gt; &gt; 区别三：&gt; &gt; 块级：块级元素可以设置margin，padding&gt; 行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。&gt; &gt; 区别四：&gt; &gt; 块级：display:block;&gt; 行内：display:inline;&gt; &gt; 可以通过修改display属性来切换块级元素和行内元素&gt; 元素不定宽高垂直居中 display:table和diaplay:table-cell 12345678910111213141516&gt; &lt;style&gt;&gt; .container &#123;&gt; display: table;&gt; &#125;&gt; .inner &#123;&gt; display: table-cell;&gt; vertical-align:middle;&gt; text-align:center;&gt; &#125;&gt; &lt;/style&gt;&gt; &lt;div class=\"container\"&gt;&gt; &lt;div class=\"inner\"&gt;&gt; you own content&gt; &lt;/div&gt;&gt; &lt;/div&gt;&gt; position:absolute、50%和translate 1234567891011121314151617&gt; &lt;style&gt;&gt; .container &#123;&gt; position: relative;&gt; &#125;&gt; .inner &#123;&gt; position: absolute;&gt; top: 50%;&gt; left: 50%;&gt; transform: translate(-50%, -50%);&gt; &#125;&gt; &lt;/style&gt;&gt; &lt;div class=\"container\"&gt;&gt; &lt;div class=\"inner\"&gt;&gt; your own content&gt; &lt;/div&gt;&gt; &lt;/div&gt;&gt; vw vh和translate 123456789101112&gt; &lt;style&gt;&gt; .inner &#123;&gt; position:fixed;&gt; top: 50vh;&gt; left: 50vw;&gt; transform: translate(-50%, -50%); &gt; &#125;&gt; &lt;/style&gt;&gt; &lt;div class=\"inner\"&gt;&gt; this is a box fixed in center of screen&gt; &lt;/div&gt;&gt; :before和display:inline-block 1234567891011121314151617181920&gt; &lt;style&gt;&gt; .container&#123;&gt; text-align: center;&gt; &#125;&gt; .container:before &#123;&gt; content: '';&gt; display: inline-block;&gt; height: 100%;&gt; vertical-align: middle;&gt; &#125;&gt; .inner &#123;&gt; display: inline-block;&gt; &#125;&gt; &lt;/style&gt;&gt; &lt;div class=\"container\"&gt;&gt; &lt;div class=\"inner\"&gt;&gt; this is a box fixed in center of screen&lt;br&gt;The second line&gt; &lt;/div&gt;&gt; &lt;/div&gt;&gt; 对闭包的看法 12345678910111213141516171819202122&gt; 要理解闭包，首先必须理解Javascript特殊的变量作用域。&gt; &gt; 变量的作用域无非就是两种：全局变量和局部变量。&gt; &gt; Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。&gt; &gt; 另一方面，在函数外部自然无法读取函数内的局部变量。&gt; &gt; 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量&gt; &gt; 出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。&gt; &gt; 那就是在函数的内部，再定义一个函数&gt; &gt; 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。&gt; &gt; 注意 :&gt; &gt; 1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。&gt; &gt; 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 &gt; 变量提升 12345678910&gt; 在ES6之前，JavaScript没有块级作用域(一对花括号&#123;&#125;即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分。&gt; &gt; 引擎在读取js代码的过程中，分为两步。第一个步骤是整个js代码的解析读取，第二个步骤是执行。 &gt; &gt; 在读取代码的过程中，就产生了将所有声明提升到顶端，然后再从上往下执行。由此产生了变量提升和函数提升。&gt; &gt; 1.变量提升只会提升变量名的声明，而不会提升变量的赋值初始化，同理，函数声明也是如此。&gt; &gt; 2.函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上。&gt; 前端性能优化减少请求数量 12345678910111213141516171819202122232425262728&gt; 【合并】&gt; 如果不进行文件合并，有如下3个隐患&gt; 1、文件与文件之间有插入的上行请求，增加了N-1个网络延迟&gt; 2、受丢包问题影响更严重&gt; 3、经过代理服务器时可能会被断开&gt; 但是，文件合并本身也有自己的问题&gt; 1、首屏渲染问题&gt; 2、缓存失效问题&gt; 所以，对于文件合并，有如下改进建议&gt; 1、公共库合并&gt; 2、不同页面单独合并&gt; 【图片处理】&gt; 1、雪碧图&gt; CSS雪碧图是以前非常流行的技术，把网站上的一些图片整合到一张单独的图片中，可以减少网站的HTTP请求数量，但是当整合图片比较大时，一次加载比较慢。随着字体图片、SVG图片的流行，该技术渐渐退出了历史舞台&gt; 2、Base64&gt; 将图片的内容以Base64格式内嵌到HTML中，可以减少HTTP请求数量。但是，由于Base64编码用8位字符表示信息中的6个位，所以编码后大小大约比原始值扩大了 33%&gt; 3、使用字体图标来代替图片&gt; 【减少重定向】&gt; 尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验&gt; 如果一定要使用重定向，如http重定向到https，要使用301永久重定向，而不是302临时重定向。因为，如果使用302，则每一次访问http，都会被重定向到https的页面。而永久重定向，在第一次从http重定向到https之后 ，每次访问http，会直接返回https的页面&gt; 【使用缓存】&gt; 使用cach-control或expires这类强缓存时，缓存不过期的情况下，不向服务器发送请求。强缓存过期时，会使用last-modified或etag这类协商缓存，向服务器发送请求，如果资源没有变化，则服务器返回304响应，浏览器继续从本地缓存加载资源；如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回200响应&gt; 【不使用CSS @import】&gt; CSS的@import会造成额外的请求&gt; 【避免使用空的src和href】&gt; a标签设置空的href，会重定向到当前的页面地址&gt; form设置空的method，会提交表单到当前的页面地址&gt; 减小资源大小 1234567891011121314&gt; 【压缩】&gt; 1、HTML压缩&gt; HTML代码压缩就是压缩在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等&gt; 2、CSS压缩&gt; CSS压缩包括无效代码删除与CSS语义合并&gt; 3、JS压缩与混乱&gt; JS压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码可读性，实现代码保护&gt; 4、图片压缩&gt; 针对真实图片情况，舍弃一些相对无关紧要的色彩信息&gt; 【webp】&gt; 在安卓下可以使用webp格式的图片，它具有更优的图像数据压缩算法，能带来更小的图片体积，同等画面质量下，体积比jpg、png少了25%以上，而且同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性&gt; 【开启gzip】&gt; HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来。一般对纯文本内容可压缩到原大小的40%&gt; 优化网络连接 12345678910111213&gt; 【使用CDN】&gt; CDN全称是Content Delivery Network，即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度&gt; 【使用DNS预解析】&gt; 当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址&gt; DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度&gt; 方法是在 head 标签里面写上几个 link 标签&gt; 【并行连接】&gt; 由于在HTTP1.1协议下，chrome每个域名的最大并发数是6个。使用多个域名，可以增加并发数&gt; 【持久连接】&gt; 使用keep-alive或presistent来建立持久连接，持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量&gt; 【管道化连接】&gt; 在HTTP2协议中，可以开启管道化连接，即单条连接的多路复用，每条连接中并发传输多个资源，这里就不需要添加域名来增加并发数了&gt; 优化资源加载 12345678910111213141516171819202122&gt; 【资源加载位置】&gt; 通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用&gt; 1、CSS文件放在head中，先外链，后本页&gt; 2、JS文件放在body底部，先外链，后本页&gt; 3、处理页面、处理页面布局的JS文件放在head中，如babel-polyfill.js文件、flexible.js文件&gt; 4、body中间尽量不写style标签和script标签&gt; 【资源加载时机】&gt; 1、异步script标签&gt; defer: 异步加载，在HTML解析完成后执行。defer的实际效果与将代码放在body底部类似&gt; async: 异步加载，加载完成后立即执行&gt; 2、模块按需加载&gt; 在SPA等业务逻辑比较复杂的系统中，需要根据路由来加载当前页面需要的业务模块&gt; 按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载&gt; webpack 提供了两个类似的技术，优先选择的方式是使用符合 ECMAScript 提案 的 import() 语法。第二种则是使用 webpack 特定的 require.ensure&gt; 3、使用资源预加载preload和资源预读取prefetch&gt; preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度&gt; prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度&gt; 4、资源懒加载与资源预加载&gt; 资源延迟加载也称为懒加载，延迟加载资源或符合某些条件时才加载某些资源&gt; 资源预加载是提前加载用户所需的资源，保证良好的用户体验&gt; 资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不做操作，浏览器空间时，再加载资源，优化了网络性能&gt; 减少重绘回流 12345678910111213141516171819202122232425262728293031323334&gt; 【样式设置】&gt; 1、避免使用层级较深的选择器，或其他一些复杂的选择器，以提高CSS渲染效率&gt; 2、避免使用CSS表达式，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次&gt; 3、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流&gt; 4、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从0到完全出现，上下左右都可能位移，发生回流&gt; 5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间&gt; 6、能够使用CSS实现的效果，尽量使用CSS而不使用JS实现&gt; 【渲染层】&gt; 1、此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围&gt; 2、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流&gt; 【DOM优化】&gt; 1、缓存DOM&gt; const div = document.getElementById('div')&gt; 由于查询DOM比较耗时，在同一个节点无需多次查询的情况下，可以缓存DOM&gt; 2、减少DOM深度及DOM数量&gt; HTML 中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。&gt; 3、批量操作DOM&gt; 由于DOM操作比较耗时，且可能会造成回流，因此要避免频繁操作DOM，可以批量操作DOM，先用字符串拼接完毕，再用innerHTML更新DOM&gt; 4、批量操作CSS样式&gt; 通过切换class或者使用元素的style.csstext属性去批量操作元素样式&gt; 5、在内存中操作DOM&gt; 使用DocumentFragment对象，让DOM操作发生在内存中，而不是页面上&gt; 6、DOM元素离线更新&gt; 对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作&gt; 7、DOM读写分离&gt; 浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行&gt; 8、事件代理&gt; 事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件&gt; 利用事件代理，可以减少内存使用，提高性能及降低代码复杂度&gt; 9、防抖和节流&gt; 使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发&gt; 10、及时清理环境&gt; 及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存&gt; 性能更好的API 12345678910111213141516171819&gt; 1、用对选择器&gt; 选择器的性能排序如下所示，尽量选择性能更好的选择器&gt; id选择器（#myid）&gt; 类选择器（.myclassname）&gt; 标签选择器（div,h1,p）&gt; 相邻选择器（h1+p）&gt; 子选择器（ul &gt; li）&gt; 后代选择器（li a）&gt; 通配符选择器（*）&gt; 属性选择器（a[rel=\"external\"]）&gt; 伪类选择器（a:hover,li:nth-child）&gt; 2、使用requestAnimationFrame来替代setTimeout和setInterval&gt; 希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用 setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧&gt; 3、使用IntersectionObserver来实现图片可视区域的懒加载&gt; 传统的做法中，需要使用scroll事件，并调用getBoundingClientRect方法，来实现可视区域的判断，即使使用了函数节流，也会造成页面回流。使用IntersectionObserver，则没有上述问题&gt; 4、使用web worker&gt; 客户端javascript一个基本的特性是单线程：比如，浏览器无法同时运行两个事件处理程序，它也无法在一个事件处理程序运行的时候触发一个计时器。Web Worker是HTML5提供的一个javascript多线程解决方案，可以将一些大计算量的代码交由web Worker运行，从而避免阻塞用户界面，在执行复杂计算和数据处理时，这个API非常有用&gt; 但是，使用一些新的API的同时，也要注意其浏览器兼容性&gt; webpack优化 1234567891011121314151617&gt; 【打包公共代码】&gt; 使用CommonsChunkPlugin插件，将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件&gt; webpack 4 将移除 CommonsChunkPlugin, 取而代之的是两个新的配置项 optimization.splitChunks 和 optimization.runtimeChunk&gt; 通过设置 optimization.splitChunks.chunks: \"all\" 来启动默认的代码分割配置项&gt; 【动态导入和按需加载】&gt; webpack提供了两种技术通过模块的内联函数调用来分离代码，优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure&gt; 【剔除无用代码】&gt; tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup&gt; JS的tree shaking主要通过uglifyjs插件来完成，CSS的tree shaking主要通过purify CSS来实现的&gt; 【长缓存优化】&gt; 1、将hash替换为chunkhash，这样当chunk不变时，缓存依然有效&gt; 2、使用Name而不是id&gt; 每个 module.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变&gt; 下面来使用两个插件解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建&gt; 【公用代码内联】&gt; 使用html-webpack-inline-chunk-plugin插件将mainfest.js内联到html文件中&gt; 前端seo优化通过网站的结构布局设计和网页代码优化，使前端页面既能让浏览器用户能够看懂，也能让“蜘蛛”看懂 1234567891011121314151617181920212223242526272829303132333435363738&gt; (1) 网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。&gt; &gt; 一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。一般中小型网站目录结构超过三级，“蜘蛛”便不愿意往下爬，“万一天黑迷路了怎么办”。并且根据相关调查：访客如果经过跳转3次还没找到需要的信息，很可能离开。因此，三层目录结构也是体验的需要。为此我们需要做到：&gt; &gt; 1. 控制首页链接数量&gt; 网站首页是权重最高的地方，如果首页链接太少，没有“桥”，“蜘蛛”不能继续往下爬到内页，直接影响网站收录数量。但是首页链接也不能太多，一旦太多，没有实质性的链接，很容易影响用户体验，也会降低网站首页的权重，收录效果也不好。&gt; 因此对于中小型企业网站，建议首页链接在100个以内，链接的性质可以包含页面导航、底部导航、锚文字链接等等，注意链接要建立在用户的良好体验和引导用户获取信息的基础之上。&gt; 2.扁平化的目录层次，尽量让“蜘蛛”只要跳转3次，就能到达网站内的任何一个内页。扁平化的目录结构，比如：“植物”–&gt; “水果” –&gt; “苹果”、“桔子”、“香蕉”，通过3级就能找到香蕉了。&gt; 3.导航优化&gt; 导航应该尽量采用文字方式，也可以搭配图片导航，但是图片代码一定要进行优化，&lt;img&gt;标签必须添加“alt”和“title”属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字。&gt; 其次，在每一个网页上应该加上面包屑导航，好处：从用户体验方面来说，可以让用户了解当前所处的位置以及当前页面在整个网站中的位置，帮助用户很快了解网站组织形式，从而形成更好的位置感，同时提供了返回各个页面的接口，方便用户操作；对“蜘蛛”而言，能够清楚的了解网站结构，同时还增加了大量的内部链接，方便抓取，降低跳出率。&gt; 4. 网站的结构布局–不可忽略的细节&gt; 1）页面头部：logo及主导航，以及用户的信息。&gt; 2）页面主体：左边正文，包括面包屑导航及正文；右边放热门文章及相关文章，好处：留住访客，让访客多停留，对“蜘蛛”而言，这些文章属于相关链接，增强了页面相关性，也能增强页面的权重。&gt; 3）页面底部：版权信息和友情链接。&gt; 特别注意：分页导航写法，推荐写法：“首页 1 2 3 4 5 6 7 8 9 下拉框”，这样“蜘蛛”能够根据相应页码直接跳转，下拉框直接选择页面跳转。而下面的写法是不推荐的，“首页 下一页 尾页”，特别是当分页数量特别多时，“蜘蛛”需要经过很多次往下爬，才能抓取，会很累、会容易放弃。&gt; 5.控制页面的大小，减少http请求，提高网站的加载速度。&gt; 一个页面最好不要超过100k，太大，页面加载速度慢。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“蜘蛛”也会离开。&gt; (2) 网页代码优化&gt; 1.&lt;title&gt;标题：只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的&lt;title&gt;标题中不要设置相同的内容。&gt; 2.&lt;meta keywords&gt;标签：关键词，列举出几个页面的重要关键字即可，切记过分堆砌。&gt; 3.&lt;meta description&gt;标签：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。&gt; 4.&lt;body&gt;中的标签：尽量让代码语义化，在适当的位置使用适当的标签，用正确的标签做正确的事。让阅读源码者和“蜘蛛”都一目了然。比如：h1-h6是用于标题类的，&lt;nav&gt;标签是用来设置页面主导航的等。&gt; 5.&lt;a&gt;标签：页内链接，要加“title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上el=\"nofollow\"属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。&gt; 6.正文标题要用&lt;h1&gt;标签：“蜘蛛” 认为它最重要，若不喜欢&lt;h1&gt;的默认样式可以通过CSS设置。尽量做到正文标题用&lt;h1&gt;标签，副标题用&lt;h2&gt;标签, 而其它地方不应该随便乱用 h 标题标签。&gt; 7.&lt;br&gt;标签：只用于文本内容的换行&gt; 8.表格应该使用&lt;caption&gt;表格标题标签&gt; 9.&lt;img&gt;应使用 “alt” 属性加以说明&gt; 10.&lt;strong&gt;、&lt;em&gt;标签 : 需要强调时使用。&lt;strong&gt;标签在搜索引擎中能够得到高度的重视，它能突出关键词，表现重要的内容，&lt;em&gt;标签强调效果仅次于&lt;strong&gt;标签。&gt; &lt;b&gt;、&lt;i&gt;标签: 只是用于显示效果时使用，在SEO中不会起任何效果。&gt; 11、文本缩进不要使用特殊符号&amp;nbsp; 应当使用CSS进行设置。版权符号不要使用特殊符号 &amp;copy; 可以直接使用输入法，拼“banquan”，选择序号5就能打出版权符号©。&gt; 12、巧妙利用CSS布局，将重要内容的HTML代码放在最前面，最前面的内容被认为是最重要的，优先让“蜘蛛”读取，进行内容关键词抓取。&gt; 13.重要内容不要用JS输出，因为“蜘蛛”不认识&gt; 14.尽量少使用iframe框架,因为“蜘蛛”一般不会读取其中的内容&gt; 15.谨慎使用display：none ：对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。因为搜索引擎会过滤掉display:none其中的内容。&gt; 16. 不断精简代码&gt; 17.js代码如果是操作DOM操作，应尽量放在body结束标签之前，html代码之后。&gt; 跨域场景 1234&gt; 出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）&gt; &gt; 当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域&gt; 非同源限制 123【1】无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB【2】无法接触非同源网页的 DOM【3】无法向非同源地址发送 AJAX 请求 方案 1234567891011121314151617181920212223&gt; 【1】设置document.domain解决无法读取非同源网页的 Cookie问题&gt; 因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）&gt; &gt; 【2】跨文档通信 API：window.postMessage()&gt; 调用postMessage方法实现父窗口http://test1.com向子窗口http://test2.com发消息（子窗口同样可以通过该方法发送消息给父窗口）&gt; 它可用于解决以下方面的问题：&gt; 页面和其打开的新窗口的数据传递&gt; 多窗口之间消息传递&gt; 页面与嵌套的iframe消息传递&gt; 上面三个场景的跨域数据传递&gt; &gt; 【3】JSONP&gt; JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。&gt; 核心思想：网页通过添加一个&lt;script&gt;元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。&gt; &gt; 【4】CORS&gt; CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。&gt; 1、普通跨域请求：只需服务器端设置Access-Control-Allow-Origin&gt; 2、带cookie跨域请求：前后端都需要进行设置&gt; 【前端设置】根据xhr.withCredentials字段判断是否带有cookie&gt; 【服务端设置】&gt; 服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。&gt; JSONP的实现原理12jsonp的本质是利用script标签的src属性进行跨域请求，只能用于get请求。jsonp是请求之后后台包装好一段json，并且把数据放在一个callback函数，返回一个js文件，动态引入这个文件，下载完成js之后，会去调用这个callback,通过这样访问数据。 正则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&gt; 1 数字：^[0-9]*$&gt; 2 n位的数字：^\\d&#123;n&#125;$&gt; 3 至少n位的数字：^\\d&#123;n,&#125;$&gt; 4 m-n位的数字：^\\d&#123;m,n&#125;$&gt; 5 零和非零开头的数字：^(0|[1-9][0-9]*)$&gt; 6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$&gt; 7 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$&gt; 8 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$&gt; 9 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$&gt; 10 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$&gt; 11 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$&gt; 12 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$&gt; 13 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$&gt; 14 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$&gt; 15 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$&gt; 16 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$&gt; 17 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$&gt; 18 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$&gt; 19 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$&gt; &gt; 二、校验字符的表达式&gt; 1 汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$&gt; 2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$&gt; 3 长度为3-20的所有字符：^.&#123;3,20&#125;$&gt; 4 由26个英文字母组成的字符串：^[A-Za-z]+$&gt; 5 由26个大写英文字母组成的字符串：^[A-Z]+$&gt; 6 由26个小写英文字母组成的字符串：^[a-z]+$&gt; 7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$&gt; 8 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$&gt; 9 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$&gt; 10 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$&gt; 11 可以输入含有^%&amp;',;=?$\\\"等字符：[^%&amp;',;=?$\\x22]+&gt; 12 禁止输入含有~的字符：[^~\\x22]+&gt; &gt; 三、特殊需求表达式&gt; 1 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&gt; &gt; 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?&gt; &gt; 3 InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$&gt; &gt; 4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$&gt; &gt; 5 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$&gt; &gt; 6 国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;&gt; &gt; 7 身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$&gt; &gt; 8 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$&gt; &gt; 9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$&gt; &gt; 10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$&gt; &gt; 11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$&gt; &gt; 12 日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;&gt; &gt; 13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$&gt; &gt; 14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$&gt; &gt; 15 钱的输入格式：&gt; &gt; 1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$&gt; &gt; 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$&gt; &gt; 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$&gt; &gt; 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$&gt; &gt; 5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$&gt; &gt; 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$&gt; &gt; 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$&gt; &gt; 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$&gt; &gt; 备注：这就是最终结果了,别忘了\"+\"可以用\"*\"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里&gt; &gt; xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$&gt; &gt; 中文字符的正则表达式：[\\u4e00-\\u9fa5]&gt; &gt; 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))&gt; &gt; 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)&gt; &gt; HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)&gt; &gt; 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)&gt; &gt; 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)&gt; &gt; 中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字)&gt; &gt; IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)&gt; &gt; IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))&gt; MVVM及实现原理 12345678910111213141516171819202122232425262728293031323334&gt; MVVM和MVC的区别&gt; &gt; MVC和MVVM的区别其实并不大。都是一种设计思想。&gt; 主要就是MVC中Controller演变成MVVM中的viewModel。&gt; MVVM主要解决了MVC中大量的DOM操作使页面渲染性能降低，加载速度变慢，影响用户体验。&gt; 当和Model频繁发生变化，开发者需要主动更新到View。&gt; &gt; MVVM：是Model-View-ViewModel的简写&gt; &gt; M：对应于MVC的M&gt; V：对应于MVC的V&gt; VM：ViewModel，是把MVC里的controller的数据加载，加工功能分离出来&gt; &gt; MVVM是Web前端一种非常流行的开发模式，&gt; 利用MVVM可以使我们的代码更加专注于处理业务逻辑而不是去关心DOM操作。&gt; 目前著名的MVVM框架有VUE，avalon，angular等&gt; &gt; MVVM设计模式的优点&gt; &gt; 1. 双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化。很好的做到数据的一致性&gt; 2. 由于控制器的功能大都移动到View上处理，大大的对控制器进行了瘦身&gt; 3. View的功能进一步强化，具有控制的部分功能，&gt; 若想无限增强它的功能，甚至控制器的全部功能几乎都可以迁移到各个View上&gt; （不过这样不可取，那样View干不了属于它职责范围内的事情）。&gt; View可以像控制器一样具有自己都View-Model&gt; 4. 可以对View或ViewController的数据处理部分抽象出来一个函数处理model。 &gt; 这样它们专职页面布局和页面跳转，它们必然更一步的简化。&gt; &gt; MVVM设计模式的缺点&gt; &gt; 1. 数据绑定也使得bug很难被调试。比如你看到页面异常了，有可能是你的View的代码有bug，也可能是你的model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。&gt; 2. 数据双向绑定不利于代码重用。客户端开发最常用的是View，但是数据双向绑定技术，让你在一个View都绑定了一个model，不同的模块model都不同。那就不能简单重用view了&gt; 3. 一个大的模块中model也会很大，虽然使用方便了也很容易保证数据的一致性，但是长期持有，不释放内存就造成话费更多的内存。&gt; 原理 1234567891011121314&gt; MVVM的实现主要是三个核心点：&gt; 响应式：vue如何监听data的属性变化&gt; 模板解析：vue的模板是如何被解析的&gt; 渲染：vue模板是如何被渲染成HTML的 &gt; &gt; 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就拿到最新值并通知订阅者。&gt; 实现一个订阅者Watcher，连接Observer和Compile。可以订阅并收到每个属性的变化通知并执行指令绑定的相应函数，从而更新视图。&gt; 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板替换数据，以及绑定相应的更新函数。&gt; mvvm入口函数，整合以上三者。&gt; &gt; 1）发布者-订阅者模式: 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set('property', value)。&gt; （2）脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，在指定的事件触发时进入脏值检测。&gt; （3）数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。&gt; 配置webpack 123456789101112131415161718192021&gt; webpack是目前前端开发中最流行的打包工具，不仅能实现 JS 打包，还能将 CSS 文件，图片文件，甚至是 LESS 文件打包，每一个文件都是一个独立的模块，并且实现按需加载。使用时需要安装 webpack 、 webpack-cli 、webpack-dev-server三个基础模块。&gt; &gt; 配置参数说明 :&gt; &gt; mode：两种 mode 模式可供选择，一种是开发环境，命令为 webpack --mode = development，打包出来的文件未经过压缩；一种是生产环境，命令是 webpack --mode = production ，打包出来的文件是经过压缩的。&gt; entry：资源入口文件，所有的资源最后会打包成一个 JS 文件。&gt; ouput：打包之后存放的文件路径。path 为相对路径，filename 为打包后的文件名。&gt; module：rules 配置编译规则，test 正则匹配，exclude 排除特定条件，use-loader，test 匹配到的解析器模块，use-options，与use-loader配合使用。&gt; plugins：插件。plugins 与 loader 的区别在于，loader 只是一个解析模块，比如将 ES5 解析成 ES6，LESS 文件解析成 CSS 文件，为了兼容浏览器。而 plugins 是将 loader 之后的文件进行优化分类、压缩、提供公共代码等。&gt; devServer：服务器配置，contentBase 文件路径，compress 是否启动 gzip 压缩，host 主机地址，port 端口号，publicPath。&gt; &gt; 常用 plugins :&gt; 1. extract-text-webpack-plugin 与 mini-css-extract-plugin&gt; 分离 .css 分解，后者需要 webpack 4.2.0 版本以上。&gt; 2. UglifyJsPlugin&gt; 压缩 js 文件，减小 js 文件。&gt; 3. html-webpack-plugin 与 html-loader&gt; 生成 html 文件。&gt; 4. clean-webpack-plugin &gt; 每次构建之前清理历史打包文件.&gt; Node.js 123456789101112131415161718192021222324252627282930313233343536373839404142&gt; 1.Node 是一个服务器端 JavaScript 解释器，可是真的以为JavaScript不错的同学学习Node就能轻松拿下，那么你就错了，总结：水深不深我还不知道，不过确实不浅。&gt; &gt; 2.Node 的目标是帮助程序员构建高度可伸缩的应用程序，编写能够处理数万条同时连接到一个物理机的连接代码。处理高并发和异步I/O是Node受到开发人员的关注的原因之一。&gt; &gt; 3.Node 本身运行Google V8 JavaScript引擎，所以速度和性能非常好，看chrome就知道，而且Node对其封装的同时还改进了其处理二进制数据的能力。因此，Node不仅仅简单的使用了V8，还对其进行了优化，使其在各种环境下更加给力。&gt; &gt; 4.第三方的扩展和模块在Node的使用中起到重要的作用。&gt; &gt; 什么是nodejs&gt; nodejs 就是JavaScript的运行环境&gt; &gt; 为什么会有nodejs&gt; 因为需要&gt; 需要JavaScript这个语言运行在服务器上&gt; node 是一个运行环境 是一个平台 开始是由一个人设计的&gt; node选择了js 而不是js发展出的node&gt; 设计了一个平台 用于运行js&gt; node环境是跨平台的&gt; node运行在服务端 没有DOM BOM&gt; &gt; node的组成&gt; ecmascript libuv&gt; 基于v8引擎&gt; &gt; REPL环境&gt; Read - Eval - Print - Loop&gt; 退出REPL Ctrl+C 连按两次 | .exit&gt; &gt; node环境的全局对象&gt; global&gt; &gt; nodejs概念&gt; nodejs是建立在谷歌v8引擎上的javascript运行环境&gt; nodejs基于非阻塞I/O模型&gt; Input/Output 都是阻塞操作&gt; 用户的输入都是无状态的 所以都是阻塞操作&gt; nodejs 它的运行环境是单线程&gt; nodejs 处理阻塞操作 通过的是 异步（回调）&gt; 单线程(主线程)主要来处理业务逻辑 执行js&gt; 遇到阻塞操作 将阻塞操作提出 放入 事件队列(Event Loop)&gt; nodejs 优势 处理高并发能&gt; BFC,产生BFC,浮动，清除浮动 12345678910111213141516171819202122232425262728293031323334&gt; 一、什么是BFC？IFC?&gt; &gt; BFC（Block Formatting Context）即“块级格式化上下文”， IFC（Inline Formatting Context）即行内格式化上下文。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态。一个框在常规流中必须属于一个格式化上下文，你可以把BFC想象成一个大箱子，箱子外边的元素将不与箱子内的元素产生作用。&gt; &gt; BFC是W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC就是一个作用范围。在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 blockformatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 InlineFormatting Context(行内格式化上下文) 里格式化。&gt; &gt; 二、BFC的特性是什么？&gt; &gt; 1、BFC会阻止外边距叠加：一般情况，两个相邻的块级框，它们之间的垂直方向的外边距会发生叠加。 如果这&gt; 两个相邻的块框不属于同一个BFC就不会叠加！&gt; BFC不会重叠浮动元素&gt; 2、一个BFC的边框不能和它里面的元素的margin重叠。这意味着浏览器将会给BFC创建隐式的外边距来阻止它和浮动元素的外边距的叠加。当给一个挨着浮动的BFC添加负得外边距不会起作用！&gt; 三、如何触发BFC?&gt; &gt; float除了none以外的值&gt; overflow除了visible之外的值&gt; display(table-cell table-caption,inline-block)&gt; position(absolute,fixed)&gt; &gt; 四、如何清除浮动&gt; &gt; css 浮动后的元素不论是什么display的都默认是block就是设置inline也是block&gt; &gt; 方式一:使用overflow属性来清除浮动.ovh&#123;overflow:hidden;&#125;&gt; 先找到浮动盒子的父元素，再在父元素中添加一个属性：overflow:hidden,就是清除这个父元素中的子元素浮动对页面的影响.&gt; 注意：一般情况下也不会使用这种方式，因为overflow:hidden有一个特点，离开了这个元素所在的区域以后会被隐藏（overflow:hidden会将超出的部分隐藏起来）.&gt; 方式二:使用额外标签法.clear&#123;clear:both;&#125;&gt; 在浮动的盒子之下再放一个标签，在这个标签中使用clear:both，来清除浮动对页面的影响.&gt; a.内部标签：会将这个浮动盒子的父盒子高度重新撑开&gt; &gt; b.外部标签：会将这个浮动盒子的影响清除，但是不会撑开父盒子.&gt; 注意：一般情况下不会使用这一种方式来清除浮动。因为这种清除浮动的方式会增加页面的标签，造成结构的混乱.&gt; 方法三:使用伪元素来清除浮动(after意思:后来,以后)&gt; 伪类和伪元素的区别 12345678&gt; 伪类其实是弥补了CSS选择器的不足，用来更方便地获取信息&gt; &gt; 而伪元素本质上是创建了一个虚拟容器(元素)，我们可以在其中添加内容或样式。&gt; &gt; 所以，你可以理解伪元素本质上是创建了一个虚拟容器(元素)了吧。&gt; &gt; 除了上面这个本质区别以外，在CSS3中，伪类用单冒号:表示；而伪元素用双冒号::表示。一个选择器可以同时使用多个伪类(但有的伪类会互斥)；而一个选择器只能同时使用一个伪元素(未来的版本可能会支持多伪元素)。&gt;","categories":[],"tags":[]},{"title":"login","slug":"login","date":"2019-12-13T12:18:59.000Z","updated":"2019-12-13T12:19:52.604Z","comments":true,"path":"2019/12/13/login/","link":"","permalink":"http://yoursite.com/2019/12/13/login/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;login&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; font-size: 16px; border: 0; outline-style: none; &#125; body&#123; background-image: url(\"./下载.jpg\"); background-repeat: no-repeat; background-size: cover; &#125; .box&#123; width: 800px; height: 500px; background-color: rgba(255, 255, 255, .6); position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); padding: 60px 50px; box-sizing: border-box; border-radius: 20px; &#125; .box p&#123; color: #fff; text-align: center; font-weight: 700; font-size: 24px; &#125; .form&#123; margin-top: 20px; display: flex; overflow: hidden; &#125; .left,.right&#123; flex: 1; padding: 10px 20px; &#125; input&#123; width: 100%; display: block; margin-bottom: 20px; height: 40px; border: 0; border-radius: 5px; padding-left: 5px; box-sizing: border-box; outline-style: none; font-weight: 700; &#125; .next&#123; width: 200px; height: 50px; margin-left: 50%; transform: translate(-50%,0); background-color: red; color: #fff; &#125; .message&#123; float: right; width: 200px; height: 40px; background-color: blue; color: #000; border-radius: 5px; font-weight: 700; &#125; .radio&#123; display: flex; &#125; .radio input&#123; margin-right: 10px; &#125; .left :nth-child(3)&#123; margin-bottom: 2px; &#125; .sure&#123; width: 20px; height: 20px; float: left; &#125; a&#123; color: #fff; padding-left: 5px; &#125; .danger&#123; width: 100%; height: 40px; border: 1px solid #fff; border-radius: 5px; padding-top: 10px; box-sizing: border-box; padding-left: 20px; color: #000; &#125; .danger input,span&#123; width: 20px; height: 20px; float: left; text-align: center; &#125; .man&#123; margin-right: 110px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;p&gt;注册成为会员&lt;/p&gt; &lt;div class=\"form\"&gt; &lt;div class=\"left\"&gt; &lt;input type=\"text\" placeholder=\"手机:\" id=\"phone\"&gt; &lt;div class=\"radio\"&gt; &lt;input id=\"code\" type=\"text\" placeholder=\"验证码:\"&gt; &lt;button id=\"getCode\" class=\"message\"&gt;获取验证码&lt;/button&gt; &lt;/div&gt; &lt;input id=\"password\" type=\"password\" placeholder=\"密码:\"&gt; &lt;input id=\"surePassword\" type=\"password\" placeholder=\"确认密码:\"&gt; &lt;input type=\"checkbox\" class=\"sure\" id=\"clause\" checked&gt; &lt;a href=\"#\"&gt;我已阅读并同意使用条款&lt;/a&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;input id=\"birthday\" type=\"text\" placeholder=\"生日 : 1999-12-31\"&gt; &lt;div class=\"danger\"&gt; &lt;input type=\"radio\" name=\"danger\" value=\"1\"&gt;&lt;span class=\"man\"&gt;男&lt;/span&gt; &lt;input type=\"radio\" name=\"danger\" value=\"0\"&gt;&lt;span&gt;女&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;button class=\"next\" &gt;下一步&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var phone = document.querySelector('#phone')// 手机号 var code = document.querySelector('#code') // 验证码 var getCode = document.querySelector('#getCode') // 获取验证码 var password = document.querySelector('#password') // 密码 var surePassword = document.querySelector('#surePassword') // 确认密码 var clause = document.querySelector('#clause') // 条款 var birthday = document.querySelector('#birthday') // 生日 var danger = document.getElementsByName('danger') // 性别 var next = document.querySelector('.next') // 手机号匹配所用正则 var phoneReg=/^[1][3,4,5,7,8][0-9]&#123;9&#125;$/ // 密码所用正则 var passwordReg =/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[^]&#123;8,16&#125;$/; getCode.onclick = ()=&gt;&#123; alert('验证码为 : 333333') &#125; // 如果取消确定阅读同意条款,禁用下一步按钮 clause.onclick = function()&#123; if(!clause.checked)&#123; next.disabled=true next.style.backgroundColor = \"#ccc\" &#125;else&#123; next.disabled=false next.style.backgroundColor = \"red\" &#125; &#125; // 点击下一步触发事件 next.onclick = function()&#123; if(!phone.value||!phoneReg.test(phone.value))return alert('手机号格式不对') if(code.value.length !== 6 || code.value!=='333333' )return alert('验证码错误') if(!password.value || !surePassword.value)return alert('请输入密码或验证码') if(password.value !== surePassword.value)return alert('验证码与密码不一致') if(!passwordReg.test(password.value)) return alert('密码格式错误 : 包含大写,小写,数字') // console.log(111); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"Vue","slug":"hello-world","date":"2019-09-19T06:17:18.316Z","updated":"2019-10-24T16:36:17.101Z","comments":true,"path":"2019/09/19/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/19/hello-world/","excerpt":"","text":"vue介绍 它是一个优秀的前端框架 通过数据来改变视图,不需要通过传统操作dom元素来改变视图 非常适用于SPA项目的开发SPA:单页面应用,仅有一个html页面 特点 响应式数据:数据驱动视图 MVVM双向绑定:数据变化,视图则变化,反之也是如此 指令:扩展了html标签的功能 组件化开发:复用代码 安装方式 本地引入 1&lt;script src=\"vue.js\"&gt;&lt;/script&gt; 在线cdn引入 npm方式引入 1npm i vue 常用实例选项概述 el(绑定视图) *作用 *: 绑定实例管理视图 值 : dom对象 注意 : 不可管理html或者body data(数据) 存放响应式数据的地方 通过vue.$data访问原始数据 vue实例代理了data上所有属性 methods(方法) 是一个对象(存放方法) 注意 : 不可重名 filter(过滤器) *场景 *: 对data中数据进行筛选时可用 使用位置 : 插值表达式内部 || v-bind中 注意 : 第一个参数默认是使用位置前面传来的数据,多个过滤器可以串行起来并排使用 分类 : 全局:所有vue实例都可用 局部:当前vue实例可用 computed(计算属性) *场景 *: 表达式过于复杂,使用计算属性 说明 : 计算属性的值依赖于data中的值 注意 : 必须有返回值,相当于对复杂逻辑的一次封装 同方法区别 : 方法每次都会执行,计算属性有缓存机制,使用一次后,将结果缓存,数据未发生改变,就去缓存中取,使用方式不需写(),方法必须使用()来进行调用 watch(数据监听) 场景 : 当数据变化,进行响应业务操作,且该操作为异步操作时,计算属性不能再使用,可用监听watch特性 使用 : key(监控数据名):value(函数) 同计算属性区别 : 计算属性为同步操作,必须有return,使用回调函数时,可能获取不到值,就已经return了 components(组件) 场景 : 重复的页面结构,数据,逻辑可以抽提为一个组件 特点 是一个特殊的vue实例 没有el,但是有template 有data,但是是一个带返回值的函数,返回值是一个对象 分类 全局 12345678Vue.component('组件名',&#123; template:``, data()&#123; return&#123; &#125; &#125;&#125;) 局部 1234567891011const vm = new Vue(&#123; components:&#123; '组件名':&#123; template:``, data()&#123; return&#123; &#125; &#125; &#125;&#125;) 嵌套 可以在new Vue()实例中使用自定义组件 也可以在注册自定义组件时,嵌套另一个自定义组件,也就是父子组件关系 局部组件 : 在谁的组件上注册,就只能在谁的组件模板(template)中使用 组件通信 父传子 将传递的值绑定在子组件标签上 子组件通过props选项来接收 传过去的值是只读的,不可修改 子传父 通过子组件的$emit(自定义事件)携带参数 父组件监听此事件,来获取子组件传递的值 mounted(渲染事件) created(渲染事件) derecive(自定义指令) 全局 : Vue实例之前定义全局自定义指令 Vue.directive(“focus”, {inserted(dom) {dom.focus();}}); 局部 : Vue的选项上定义 directives: {focus: {inserted(dom) {dom.focus();}}} ref 作用 通过此特性可以获取dom元素 使用 dom元素设置ref属性 1&lt;input type=\"text\" ref=\"myInput\" /&gt; 通过$refs.名称来获取dom对象 1this.$refs.myInput.focus(); 插值表达式(Mustache) 作用 将绑定的数据实时显示出来(响应式数据) 格式 通过包裹的形式 注意 内部中支持JavaScript表达式 每个绑定都只能包含单个表达式 不支持语句 不支持流控制(可用三元表达式) 里面只能使用内置全局变量,如:Data(),Math() 指令(Directives) 介绍 格式 : 是带有v-前缀的特殊特性 作用 : 扩展html的功能,指令的职责是当表达式的值改变时,将其产生的连带影响,响应式的作用于DOM 位置 : 起始标签 语法 : v-指令=”表达式” ||v-指令=”‘字符串’” 系统指令 v-text : v-text更新整个标签中的内容 v-html : 可以渲染内容中的html标签 v-if : 后面表达式返回布尔值决定是否隐藏(更高的切换开销,运行时条件很少改变推荐使用) v-show : 后面表达式返回布尔值决定是否隐藏(更高的初始渲染开销,频繁切换隐藏推荐) v-on : 给元素绑定事件 格式 : v-on:事件名.修饰符=”方法名” 简写 : @事件名 = “方法名” v-for : 循环遍历数组或对象,生成dom元素 参数(item,index,key) item : 当前项 index : 索引 key : 对象可用键名 v-bind : 绑定标签上的属性 场景 : 当标签上的属性是变量/动态/需要改变的 格式 v-bind : 属性名 = “变量名” :属性名 = “变量名” 语法糖 绑定class 对象语法 :class = &quot;{class名称:布尔值}&quot; 数组语法:class = &quot;[class变量1,class变量2...]&quot; 绑定style 对象语法:style = &quot;{css属性名 : 变量}&quot; 数组语法:style = &quot;[对象1,对象2...]&quot; v-model : 表单元素的绑定 input/checkout/textarea 特点 : 双向数据绑定,它会忽略所有表单的value,checked,selected特性的初始值而总是将实例的数据作为数据来源,应该在data选项中声明初始值 语法 : v-model = &quot;变量&quot; 原理 : v-on + v-bind,当表单值改变,触发事件,重新赋值给数据,数据改变,刷新视图,做到数据双向绑定 v-cloak : 解决页面闪烁问题,在实例视图上引用 v-cloak v-once : 使得所在元素只渲染一次,静态化数据,不建议使用在顶级div上,会造成响应式数据的失效 发送网络请求 vue-resource vue.js的插件,已经不维护,不推荐使用 axios 不是vue的插件,可在任何地方使用,推荐 可在浏览器端,node.js中使用的发http请求的库,支持promise,不支持jsonp axios 优点` 支持浏览器和node.js, 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造) 使用 123456789101112// 方式一axios.类型(地址) .then(成功回调函数) .catch(失败回调函数)// 方式二axios.(&#123; url:地址 method:类型 data:&#123;携带参数&#125;&#125;) .then(成功回调函数) .catch(失败回调函数) 注意 post请求成功,status值为201,其余请求为200 json-server 介绍 快速搭建一个后台的接口服务,供前端调用 是一个命令行工具,可以把json文件变成接口文件 遵循restfull接口规则 安装 1npm i -g json-server 使用 1json-server --watch json文件名 RESTFUL(接口规范) 介绍 用不同请求类型,发送同一个请求标识,所对应的的处理是不同的 支持模糊搜索 GET /brands?字段名_like=关键字 SPA 同传统页面区别 传统页面 每个页面及其内容都需要从服务器一次次请求,网络差的话,体验则会感觉很慢 SPA页面 第一次加载会将所有的资源都请求到页面.模块之间切换,不会再请求服务器 优点 用户体验好,前端操作几乎感受不到网络的延迟 完全组件化开发,因为只有一个页面,所以原来属于一个个页面的工作被归类为一个个组件 缺点 首屏加载慢–解决方案 : 按需加载,不刷新页面,只请求js模块 不利于SEO–解决方案 : 服务端渲染(node-&gt;自己写路由-&gt;express-art-template + res.render()) 开发难度高(框架)相对于传统模式,有一些学习成本和应用成本 原理 需求 实现能够在前端自由切换模块 要能记忆当前切换到模块,并且刷新页面模块依然还在当前视图 实现在前段切换模块时,不能引起页面刷新,否则页面内容会被重置 结论 可以通过页面地址的锚链接来实现SPA hash(锚链接)位于连接地址#之后 hash值的改变不会触发页面刷新 hash值的url地址的一部分,会存储在页面地址上,我们可以获取到 可以通过事件监听hash值的改变 拿到了hash值,就可以根据不同的hash值进行不同的模块切换 vue-router 介绍 是Vue.js官方的路由管理器,它和Vue.js的核心深度集成,让构建单页面应用变得易如反掌,它是一个插件 实现根据不同的请求地址,而显示不同的组件 如果要用vue开发项目,前端路由功能必须使用vue-router来实现 使用 1.下载并导入 2.设置html内容 3.创建组件 4.实例化路由对象,配置路由规则 5.vue实例挂载路由 动态路由 场景 页面跳转需要协带参数,会导致页面path不同,而却需要对应一个组件,所需需要用到动态路由 方案 路由规则中增加参数,在path最后增加 :id 这里的id相当于我们给路由加了参数,叫做id 通过传参,在路径上传入具体的值(实参) 在组件内部可以使用,this.$route获取当前路由对象,并通过params获取定义的参数id 属性赋值 方式 常规跳转–&lt;router-link to=&quot;/sport&quot;&gt;体育&lt;/router-link&gt; 变量–&lt;router-link :to=&quot;path&quot;&gt;体育&lt;/router-link&gt; 根据对象name跳转–&lt;router-link :to=&quot;{name:&#39;abcdefg&#39;}&quot;&gt;体育&lt;/router-link&gt; 根据对象path跳转–&lt;router-link :to=&quot;{path:&#39;/sport&#39;}&quot;&gt;体育&lt;/router-link&gt; 带参数的跳转–&lt;router-link :to=&quot;{name:&#39;abcdefg&#39;,params:{a:1}}&quot;&gt;体育&lt;/router-link&gt; 注意 如果提供了path,params会被忽略,上述例子中name并不属于这种情况,你可以提供路由的name并手写完整的参数params 重定向 场景 当希望某个页面被强制中转时,可采用redirect进行路由重定向设置(拦截谁就在谁的路由表上写redirect) 编程式导航 跳转不同的组件,不仅仅可以用router-link,还可以采用代码行为 (Vue实例)this.$router可以拿到当前路由对象的实例 注意 :前面小节获取数据用到的是$route,这里用到的是$router 路由对象的实例方法 push()相当于往历史记录里面推了一条记录,如果点击返回,会回到上一次的地址 replace()相当于替换当前的记录,历史记录并没有多,但是地址会变 go()代表希望是前进还是回退,当数字大于0时,就是前进n(数字)次,小于0时,就是后退n(数字)次 设置当前激活路由的样式 当前路由在导航中是拥有激活class样式的 审查导航元素,可以发现激活样式,设置即可 嵌套路由 如果存在路由嵌套,就需要提供多个视图容器 同时,router-link和router-view都可以添加类名,设置样式 注意 以/开头的嵌套路径会被当做根路径,这让你充分的使用嵌套而无需设置嵌套的路径 如果一个需要给子路由一个默认的显示,就可以配置一个默认的选型 Vue中的动画过渡 介绍 Vue提供了transtion的封装组件,在以下情形中,可以给任何元素和组件添加进入/离开过渡 基本用法 就是给我们需要动画的标签外面嵌套transition标签,并且设置name属性 12345&lt;transition name=\"fade\"&gt; &lt;div v-show=\"isShow\" class=\"box\"&gt;&lt;/div&gt;&lt;/transition&gt; class6种状态 v-enter定义进入过渡的开始状态 v-enter-active定义进入过渡生效时的状态 v-enter-to2.1.8版本及以上定义进入过渡的结束状态 v-leave定义离开过渡的开始状态 v-leave-active定义离开过渡生效时的状态 v-leave-to2.1.8版本及以上定义离开过渡的结束状态 注意 v要替换成transition组件的name属性值 先要编写元素的最终展示样式 vue-cli 介绍 是一个辅助开发工具,可以进行代码编译,样式,语法校验,输出设置,其他… 一个命令行工具,最新版本也支持图形化操作,可快速搭建大型网页应用 本质上是一个npm包,也需要npm去安装下载 作用 可以为开发者提供一个标准的项目开发结构和配置 安装 123npm i -g @vue-cli //全局安装最新版本npm install -g @vue-cli-init //安装桥接工具,将2.0的功能补齐到当前脚手架上vue -V //查看版本 等同 vue --version 2.0创建项目 1234vue init webpack-simple 项目名 //webpack-simple为模板名称 固定写法cd 项目目录 //切换到项目目录npm install //安装依赖npm run dev //在开发模式下,启动运行项目 3.0创建项目 123vue create 项目名 //创建项目(create为关键字)cd 项目目录 //切换到当前目录npm run serve //在开发模式下,启动运行项目 3.0创建项目时,有两种模式,一个默认模式,一种选择模式 项目目录文件介绍 .bablelrc存放babel编译的配置信息 .editorconfig存放编辑器的配置信息 .gitignoregit忽略文件 index.html单页应用的html package.json用于存放依赖信息及其他项目信息 README.md项目介绍信息,github上的页面信息 webpack.config.jswebpack工具的配置文件,前端工程化的工具,编译代码,压缩代码,处理代码.其他… main.js入口 build.js出口 导入&amp;导出 import变量from路径 引入组件 export default 对象 导出组件 单文件组件及入口分析 介绍 一个.vue文件就是一个组件 一个组件分为三个部分 template(页面模板) scrip(组件逻辑) style(组件样式) 注意 vue选项中的render函数若存在,则vue构造函数不会从template选项或通过el选项指定的挂载元素中提取出的html模板编译渲染函数 vue-cli的作用就是让我们把精力放在业务编码上,一切准备的工作交给vue-cli去做 生命周期函数Vue实例从创建到销毁的过程，就是生命周期。从开始创建，初始化数据，编译模板，挂载Dom-&gt;渲染，更新-&gt;渲染，销毁等一系列过程，称之为vue的生命周期。 第一阶段 beforeCreate（创建前），在实例创建之前执行，数据未加载状态； created (创建后)：在实例创建、数据加载后；能初始化数据，DOM渲染之前执行； 第二阶段 beforeMount（载入前），虚拟 DOM 已创建完成，在数据渲染前最后一次更改数据； mounted（载入后），页面、数据渲染完成，真实 DOM 挂载完成； 第三阶段 BeforeUpdate（更新前），重新渲染之前触发； Updated（更新后），数据已经更改完成，DOM 也重新 render 完成，更改数据会陷入死循环； 第四阶段 beforeDestroy（销毁前），在实例销毁之前调用，实例仍然完全可用。 Destroyed（销毁后），在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 双向绑定原理 vue进行实例化的时候,会对data选项中的所有属性进行遍历,并使用object.defineProperty转化这些属性为getter/setter,vue中每个组件实例都会对应一个watcher实例,渲染之前的数据作为依赖,当数据发生了改变就会触发setter,就会通知给watcher,从而使所有与其关联组件重新渲染.","categories":[],"tags":[]},{"title":"面试题","slug":"面试题","date":"2014-10-25T16:56:20.000Z","updated":"2019-10-25T17:16:56.464Z","comments":true,"path":"2014/10/26/面试题/","link":"","permalink":"http://yoursite.com/2014/10/26/面试题/","excerpt":"","text":"HTML+CSS 块级元素水平垂直居中 CSS方式 1234567// 父盒子设置display:table-cell;text-align:center;vertical-align:middle;// 块级元素设置display:inline-block;vertical-align:middle; CSS3方式 1234567// 父盒子设置position:relative;// 块级元素设置position:absolute:top:50%;left:50%transform:translate(-50%,-50%) position的属性及作用 px/em/rem的区别 简述BFC css引入方式，link与@import的区别 css reset的作用及使用场景 css sprites的使用方式 清除浮动的方式 简述适应不同分辨率的几种方法 简述优雅降级与渐进增强 结构与表现分离，简述结构/表现是什么 简述对Web语义化的理解 css选择器及优先级 display：none与visibility：hidden的区别 给p标签设置样式，实现字体在IE6为黑色，IE7为红色，其他为绿色","categories":[{"name":"Interview","slug":"Interview","permalink":"http://yoursite.com/categories/Interview/"}],"tags":[]}]}