<!DOCTYPE html>
<html lang="en">

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    随记 |  空欢
  </title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">  <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">  <script src="/js/pace.min.js"></script>

  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-随记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  随记
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/25/随记/" class="article-date">
  <time datetime="2019-12-25T15:19:47.000Z" itemprop="datePublished">2019-12-25</time>
</a>
      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="H5相关"><a href="#H5相关" class="headerlink" title="H5相关"></a>H5相关</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; - 语义化标签[header,nav,main,section,aside,articel,footer]--有利于SEO,易读,便于开发与维护</span><br><span class="line">&gt; - 自定义属性,标签本身不带的属性,JS中可以通过dataset[属性名]来获取到</span><br><span class="line">&gt; - 表单新特性 : calendar,date,time,email,url,search,tel,file,number</span><br><span class="line">&gt; - 多媒体视频(video)和音频(audio)</span><br><span class="line">&gt; - web存储 : (都只能存储字符串)</span><br><span class="line">&gt; sessionStorage : 关闭浏览器清空数据,大小<span class="number">5</span>M</span><br><span class="line">&gt; localStorage1 : 永久有效,大小<span class="number">20</span>M,多窗口都可使用</span><br><span class="line">&gt; - canvas : 画布</span><br><span class="line">&gt; - webworker : 多线程,一旦建立四种运行,不被主线程打断,同源限制,dom限制,没有<span class="built_in">window</span>,parent,<span class="built_in">document</span>对象</span><br><span class="line">&gt; - webscoket : 	客户端和服务端都可以主动的推送消息，可以是文本也可以是二进制数据(不会产生跨域),</span><br><span class="line">&gt;     协议的标识符就是ws。像https一样如果加密的话就是wxs。</span><br><span class="line">&gt; - 拖拽api : dragstart开始,drag过程中,dragend结束</span><br><span class="line">&gt; - 地理API</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="C3相关"><a href="#C3相关" class="headerlink" title="C3相关"></a>C3相关</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; - 选择器 : 属性选择器E[attr],伪类选择器E:nth-child(n),空伪类E:empty ,排除伪类E:not(selector)</span><br><span class="line">&gt; - 颜色 : 新增rgba与hsla模式</span><br><span class="line">&gt; - 文本 : 文本阴影,text-shadow,设置偏移量h-shadow&amp;v-shadow,模糊度blur,颜色(可设置透明度)color</span><br><span class="line">&gt; - 盒模型 : box-sizing:border-box</span><br><span class="line">&gt; - 边框 : 圆角border-radius,阴影box-shadow</span><br><span class="line">&gt; - 背景 : background-size尺寸;background-origin定位参照原点;background-clip裁切</span><br><span class="line">&gt; - 渐变 : linear-gradient线性;radial-gradient径向</span><br><span class="line">&gt; - <span class="number">2</span>D转换 : trandlate位移;scale缩放;rotale旋转;transform-origin转换元素原点</span><br><span class="line">&gt; - <span class="number">3</span>D转换 : perspective透视;transform-style:persevere<span class="number">-3</span>d给父元素设置转<span class="number">3</span>D立体;backface-visibility:hidden背景可见</span><br><span class="line">&gt; - 动画 : @keyframes定义;百分比编写;animation将动画应用于相对元素</span><br><span class="line">&gt; - 媒体查询 : @media screen and (宽高)&#123;...&#125;</span><br><span class="line">&gt; - 字体图标 : font-face</span><br><span class="line">&gt; - 弹性布局 : flex</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; - 变量声明 : 暂时性死区</span><br><span class="line">&gt;         a. let-块级作用域,声明便令,先声明后用,同块不可重复声明,无变量提升	</span><br><span class="line">&gt;   	b. const-块级作用域,声明常量,声明即赋值,否则报错,不可重新赋值</span><br><span class="line">&gt; - 解构赋值 : <span class="keyword">let</span>&#123;a&#125;=&#123;<span class="attr">a</span>:<span class="number">5</span>&#125;,对象通过键名对应,数组通过索引对应</span><br><span class="line">&gt; - 模板字符串 : 支持换行,插入变量使用<span class="string">'$&#123;&#125;'</span></span><br><span class="line">&gt; - 函数扩展 : 箭头函数,内部没有<span class="keyword">this</span>,没有<span class="built_in">arguments</span></span><br><span class="line">&gt; - 参数默认值 : <span class="function"><span class="keyword">function</span> <span class="title">printText</span>(<span class="params">text = <span class="string">'default'</span></span>) </span>&#123;<span class="built_in">console</span>.log(text);&#125;</span><br><span class="line">&gt; - Spread : 展开运算符,将对象或数组分解为一个一个元素</span><br><span class="line">&gt; - Rest : 放在形参末尾,接收剩余参数为数组</span><br><span class="line">&gt; - <span class="class"><span class="keyword">class</span>类的概念,通过<span class="keyword">extends</span>继承父类,通过<span class="title">super</span>继承父类构造函数与普通函数</span></span><br><span class="line"><span class="class">&gt; - <span class="title">for</span> <span class="title">of</span> 与<span class="title">for</span> <span class="title">in</span> 前者用于遍历迭代器,后者用于遍历对象属性</span></span><br><span class="line">&gt; - 模块化 : import XXX from "XXX"导入;export default XXX导出</span><br><span class="line">&gt; - 数据结构</span><br><span class="line">&gt;         a. set : 类似于数组,值都是唯一的</span><br><span class="line">&gt;   	b. weakSet : 成员只能是对象,里面的引用,都不计入垃圾回收机制,不可遍历,没有size</span><br><span class="line">&gt;   	c. map : 类似于对象,也是键值对集合,但是键名的范围不局限在字符串</span><br><span class="line">&gt;   	d. weakMap : 类似于map.只接受对象作为键名(除<span class="literal">null</span>),里面的引用都不计入垃圾回收机制,不可遍历,没有size</span><br><span class="line">&gt; - <span class="built_in">Array</span>.from() : 非数组转数组(有length,可遍历的类似数组)</span><br><span class="line">&gt; - <span class="built_in">Array</span>.of() : 将一组值转换为数组</span><br><span class="line">&gt; - 数组方法 : </span><br><span class="line">&gt;         a. copyWithin() : 将指定位置成员复制到其他位置,会覆盖原有成员,然后返回当前数组,会修改当前数组</span><br><span class="line">&gt;   	b. find() 和 findIndex() 返回符合条件的数组成员,无则<span class="literal">undefined</span></span><br><span class="line">&gt;   	c. fill() : 填充数组,(元素,开始位置,结束位置)</span><br><span class="line">&gt;   	d. entries()，keys() 和 values() : 遍历数组,返回一个遍历器对象,可用<span class="keyword">for</span> <span class="keyword">of</span>变量,对键值对,键,值的遍历</span><br><span class="line">&gt;   	e. includes() : <span class="built_in">Array</span>.prototype.includes返回布尔,表示是否包含给定的值,类似字符串includes方法</span><br><span class="line">&gt; - 字符串方法 :</span><br><span class="line">&gt; a. includes()：返回布尔值，表示是否找到了参数字符串。</span><br><span class="line">&gt;   	b. startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</span><br><span class="line">&gt;   	c. endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</span><br><span class="line">&gt;   	d. repeat() : 重复原字符串n次</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="减少页面加载时间"><a href="#减少页面加载时间" class="headerlink" title="减少页面加载时间"></a>减少页面加载时间</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> 懒加载</span><br><span class="line">&gt; <span class="number">2.</span> 减少重复的http请求</span><br><span class="line">&gt; <span class="number">3.</span> 服务器开启gzip压缩</span><br><span class="line">&gt; <span class="number">4.</span> 压缩合并js，css代码</span><br><span class="line">&gt; <span class="number">5.</span> 应用精灵图</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="headerlink" title="渐进增强和优雅降级"></a>渐进增强和优雅降级</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> 渐进增强是从低级的现状开始，然后不断添加完善功能</span><br><span class="line">&gt; <span class="number">2.</span> 优雅降级是从比较完整的现状开始，然后向下兼容</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="web应用从服务器主动推到Data到客户端"><a href="#web应用从服务器主动推到Data到客户端" class="headerlink" title="web应用从服务器主动推到Data到客户端"></a>web应用从服务器主动推到Data到客户端</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> html5 websocket</span><br><span class="line">&gt; <span class="number">2.</span> WebSocket 通过 Flash</span><br><span class="line">&gt; <span class="number">3.</span> XHR长时间连接</span><br><span class="line">&gt; <span class="number">4.</span> XHR Multipart Streaming</span><br><span class="line">&gt; <span class="number">5.</span> 不可见的Iframe</span><br><span class="line">&gt; <span class="number">6.</span> script标签的长时间连接(可跨域)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="jsonp的原理，优缺点"><a href="#jsonp的原理，优缺点" class="headerlink" title="jsonp的原理，优缺点"></a>jsonp的原理，优缺点</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> json是对象简谱，是一种数据格式</span><br><span class="line">&gt; <span class="number">2.</span> jsonp是json的一种“使用模式”,可用于解决主流浏览器的跨域数据访问的问题</span><br><span class="line">&gt; 原理：所有主流浏览器出于安全因素考虑都有同源策略，而HTML中的script标签则不受此限制，jsonp的本质是利用script标签的src属性进行跨域请求</span><br><span class="line">&gt;   优点：不受同源限制</span><br><span class="line">&gt;   	缺点：只能用于<span class="keyword">get</span>请求，不能用于post请求	</span><br><span class="line">&gt;   补充 : jsonp调用方页面上使用script标签引用第三方API地址；第三方响应的数据是JSON数据的包装（callback（&#123;&#125;）），其中函数的实参是json对象，可以再callback函数中进行数据处理。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="javaScript同源策略"><a href="#javaScript同源策略" class="headerlink" title="javaScript同源策略"></a>javaScript同源策略</h1><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 协议，域名，端口号</span><br><span class="line">&gt; </span><br><span class="line">&gt; 同源策略 是由NetScape提出的一个著名的安全策略。所谓的同源，指的是协议，域名，端口相同。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="js请求有哪些地方会有缓存处理"><a href="#js请求有哪些地方会有缓存处理" class="headerlink" title="js请求有哪些地方会有缓存处理"></a>js请求有哪些地方会有缓存处理</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> DNS缓存 : 短时间内多次访问某个网站，在限定时间内，不用多次访问DNS服务器。</span><br><span class="line">&gt; <span class="number">2.</span> CDN缓存 : 内容分发网络（人们可以在就近的代售点取火车票了，不用非得到火车站去排队）</span><br><span class="line">&gt; <span class="number">3.</span> 浏览器缓存 : 浏览器在用户磁盘上，对最新请求过的文档进行了存储。</span><br><span class="line">&gt; <span class="number">4.</span> 服务器缓存 : 将需要频繁访问的Web页面和对象保存在离用户更近的系统中，当再次访问这些对象的时候加快了速度。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="typeof和instanceof区别"><a href="#typeof和instanceof区别" class="headerlink" title="typeof和instanceof区别"></a>typeof和instanceof区别</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> 判断一个变量的类型可以用<span class="keyword">typeof</span>,检测数据类型</span><br><span class="line">&gt; <span class="number">2.</span> <span class="keyword">instanceof</span>用于判断某个对象是否被另一个函数构造</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="返回null，undefind-二者区别"><a href="#返回null，undefind-二者区别" class="headerlink" title="返回null，undefind,二者区别"></a>返回null，undefind,二者区别</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> <span class="literal">null</span>是js中的关键字，表示空值，<span class="literal">null</span>可以看作是object的一个特殊的值，如果一个object值为空，表示这个对象不是有效对象；</span><br><span class="line">&gt; <span class="number">2.</span> <span class="literal">undefined</span>不是js中的关键字，其是一个全局变量，是Global的一个属性，以下情况会返回<span class="literal">undefined</span>:</span><br><span class="line">&gt; 	a. 声明但是没有赋值的变量的值为<span class="literal">undefined</span></span><br><span class="line">&gt;   	b. 使用不存在的属性的返回值是<span class="literal">undefined</span></span><br><span class="line">&gt;   	c. 调用没有返回值的函数，返回值也是<span class="literal">undefined</span></span><br><span class="line">&gt;   	e. 调用函数时，该提供的参数没有提供</span><br><span class="line">&gt;   区别 : </span><br><span class="line">&gt;   	a. 类型不一样；</span><br><span class="line">&gt;   	b. 转化为值时不一样：<span class="literal">undefined</span>为<span class="literal">NaN</span> ,<span class="literal">null</span>为<span class="number">0</span>；              </span><br><span class="line">&gt;   	c. undefined===<span class="literal">null</span>;<span class="comment">//false              undefined==null;//true</span></span><br><span class="line">&gt;   	e. isNaN(<span class="literal">null</span>)<span class="comment">//false   isNaN(undefined)//true</span></span><br><span class="line">&gt;   	f. typeof <span class="literal">null</span><span class="comment">//object   typeof undefined//undefined</span></span><br><span class="line">&gt;   	备注：<span class="literal">null</span>当使用完一个比较大的对象时，需要对其进行释放内存时，设置为<span class="literal">null</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="多图片优化"><a href="#多图片优化" class="headerlink" title="多图片优化"></a>多图片优化</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> 精灵图</span><br><span class="line">&gt; <span class="number">2.</span> 懒加载</span><br><span class="line">&gt; <span class="number">3.</span> 预加载-幻灯片之类的使用,将当前展示图片的前一张和后一张优先下载</span><br><span class="line">&gt; <span class="number">4.</span> 使用特殊编码的图片。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="变量提升和函数提升有什么区别"><a href="#变量提升和函数提升有什么区别" class="headerlink" title="变量提升和函数提升有什么区别"></a>变量提升和函数提升有什么区别</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> 所有的声明都会提升到作用域的最顶上去</span><br><span class="line">&gt; <span class="number">2.</span> 同一个变量只会声明一次，其他的会被忽略掉</span><br><span class="line">&gt; <span class="number">3.</span> 函数声明的优先级高于变量申明的优先级，并且函数声明和函数定义的部分一起被提升</span><br><span class="line">&gt; 注意 : </span><br><span class="line">&gt;   	a. 只有声明本身会被提升，而赋值操作不会被提升。</span><br><span class="line">&gt;   	b. 变量会提升到其所在函数的最上面，而不是整个程序的最上面</span><br><span class="line">&gt;   	c. 函数声明会被提升，但函数表达式不会被提升。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="安卓手机边框圆角会失效，解决方案"><a href="#安卓手机边框圆角会失效，解决方案" class="headerlink" title="安卓手机边框圆角会失效，解决方案"></a>安卓手机边框圆角会失效，解决方案</h1><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 安卓部分低版本系统，不支持border-radius:50%;的写法</span><br><span class="line">&gt; 1. 设置border：none; 去掉边框</span><br><span class="line">&gt; 2. 设置border-radius:40px; 若遇到浏览器兼容的?问题，可加上兼容的css代码</span><br><span class="line">&gt; 3. 最后，使用box-shadow: 0px 0px 5px #ccc; 利用该特性设置边框</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="innerText火狐不可以用"><a href="#innerText火狐不可以用" class="headerlink" title="innerText火狐不可以用"></a>innerText火狐不可以用</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> firefox改成了textContent方法/属性，Firefox中文本中间的空白字符被替换了；</span><br><span class="line">&gt; <span class="number">2.</span> 使用obj.innerText提取文本</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="ie8在png格式的图片不能显示"><a href="#ie8在png格式的图片不能显示" class="headerlink" title="ie8在png格式的图片不能显示"></a>ie8在png格式的图片不能显示</h1><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;      方法一 : 重新注册pngfilt.dll文件。</span><br><span class="line">&gt;      方法二 : 注册表中“Internet Settings”值被更改</span><br><span class="line">&gt;      方法三 : 改注册表中“MIME”项</span><br><span class="line">&gt;      原因 :其他软件（如quicktime）安装时，替换了windows原有的Pngfilt.dll文件，导致pngfilt.dll加载不成功。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h1><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; IE : e.cancelBubble = true</span><br><span class="line">&gt; w3c : e.stopPropagation()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="阻止某个事件的默认行为"><a href="#阻止某个事件的默认行为" class="headerlink" title="阻止某个事件的默认行为"></a>阻止某个事件的默认行为</h1><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;      w3c方法是e.preventDefault;</span><br><span class="line">&gt;      IE中方法是window.event.returnValue = false;</span><br><span class="line">&gt;      (首先对事件冒泡和默认行为以及要用到的事件对象event有个认识</span><br><span class="line">&gt;      对事件冒泡的理解是当触发一个子元素的事件时，同时它的父元素的事件也会依次被触发。即事件从最低层元素依次向最外层元素触发</span><br><span class="line">&gt;      默认事件（行为）指的是有些元素自身会有一些行为会自行被触发。例如&lt; a&gt;链接，提交按钮&lt; input type = ‘submit’/&gt;</span><br><span class="line">&gt;      event代表事件的状态。例如触发event对象的元素、鼠标的位置及状态，按下的键等等</span><br><span class="line">&gt;      event只在事件发生的过程中才有效</span><br><span class="line">&gt;      不同的浏览器用到event时会有所不同：例如IE里面是全局变量，即window.event；而火狐firefox里面是临时变量，需要用参数引导才可以用)</span><br><span class="line">&gt;      javaScript的return只会阻止默认行为，而jQuery的return false两者都会阻止。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="闭包-场景"><a href="#闭包-场景" class="headerlink" title="闭包,场景"></a>闭包,场景</h1><blockquote>
<p>“闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。”<br>1.模仿块级作用域，避免全局污染；<br>2.储存变量，闭包的另一个特点是可以保存外部函数的变量，内部函数保留了对外部函数的活动变量的引用，所以变量不会被释放。<br>3.封装私有变量，把函数当作一个范围，函数内部的变量就是私有变量，在外部无法引用，但是我们可以通过闭包的特点来访问私有变量。</p>
</blockquote>
<h1 id="xhr对象在IE和火狐中的创建方式"><a href="#xhr对象在IE和火狐中的创建方式" class="headerlink" title="xhr对象在IE和火狐中的创建方式"></a>xhr对象在IE和火狐中的创建方式</h1><blockquote>
<p>IE中通过new ActiveXObject()得到<br>Firefox中通过new XMLHttpRequest()得到</p>
</blockquote>
<h1 id="ajax和js的区别"><a href="#ajax和js的区别" class="headerlink" title="ajax和js的区别"></a>ajax和js的区别</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> AJAX就是“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。</span><br><span class="line">&gt; <span class="number">2.</span> 它不是一种语言，它算是一个多种语言共同协助的一个技术。</span><br><span class="line">&gt; <span class="number">3.</span> Ajax主要用于创建快速动态网页的技术。</span><br><span class="line">&gt; <span class="number">4.</span> Javascript是一个开发语言，在使用ajax技术中，需要使用到它</span><br><span class="line">&gt; 二者区别 : ajax是一种多技术的综合使用（其中包含了javascript），javascript只是一种脚本语言</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="ajax一共有几种callback"><a href="#ajax一共有几种callback" class="headerlink" title="ajax一共有几种callback"></a>ajax一共有几种callback</h1><blockquote>
<p>八种：<br>​    onSuccess；<br>​    onFailure；<br>​    onUninitialized；<br>​    onLoading；<br>​    onLoaded；<br>​    onInteractive；<br>​    onComplete；<br>​    onException。</p>
</blockquote>
<h1 id="ajax接受到的数据类型及处理"><a href="#ajax接受到的数据类型及处理" class="headerlink" title="ajax接受到的数据类型及处理"></a>ajax接受到的数据类型及处理</h1><blockquote>
<p>String,JSON串,JSON对象<br>xhr常用的方法和属性 : </p>
<pre><code>1) open( ) -方法
     作用：创建请求
     语法：open(“method”,”url”,isAsyn)
        ① method 请求方式：POST或GET
        ② url 请求地址
        ③ isAsyn 使用 同步(false) 还是 异步(true) 的方式发送请求</code></pre><p>​    2）readyState - 属性<br>​        作用：<br>​        0：请求发送还未发送<br>             ①已经打开到WEB服务器的连接<br>             ②xhr对象已经接受响应消息的头部<br>             ③xhr对象已经接受响应消息的主体<br>             ④xhr已经接受完成响应消息<br>​        注意：当readyState为4的时候，表示所有的响应消息都接受完毕<br>​    3）status -属性<br>​        作用：表示服务器相应状态码<br>​        1消息<br>​        2成功<br>​        3重定向<br>​        4请求错误<br>​        5服务器错误<br>​        值：<br>             200 正常接受请求以及给出响应<br>​            403 拒绝访问<br>​            401 当前请求需要用户验证<br>             404 要请求的资源不存在<br>             500 服务器内部错误<br>​            注意：当status值是200的时候<br>​    4）onreadystatechange - 事件<br>​        当xhr的readyState发生改变时，要自动激发的操作。用于监听readyState状态改变的<br>​        xhr.onreadystatechange=function(){<br>​        //每当readyState状态码发生改变的时候要执行的操作<br>​        if(xhr.readyState==4 &amp;&amp; xhr.status==200){<br>​        //当xhr已经完全接收响应了，并且服务器也正常给出响应的时候要做的事<br>​        var txt=xhr.responseText;//服务器端响应回来的数据<br>​            }<br>​        }<br>​    5）send( ) -方法<br>​        作用：发送请求<br>​        语法：xhr.send(body);<br>​        body：发送的请求数据。如果是get提交方式，此处为null；如果是post提交方式，此处就是提交的数据</p>
</blockquote>
<h1 id="取消移动页面缩放"><a href="#取消移动页面缩放" class="headerlink" title="取消移动页面缩放"></a>取消移动页面缩放</h1><blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0"</span> /&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="三次握手，为什么不用一次"><a href="#三次握手，为什么不用一次" class="headerlink" title="三次握手，为什么不用一次"></a>三次握手，为什么不用一次</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 只一次的话，服务器没有回复，肯定不行，两次的话，如果因为某种情况（像是网络不好等）导致客户端没有收到服务端的回复，之后客户端发新请求收到正常回复，但是之前没收到的失效回复服务端不知道它已经失效，会一直为他委会着资源，这就造成了资源的浪费。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="loader，plugin的区别"><a href="#loader，plugin的区别" class="headerlink" title="loader，plugin的区别"></a>loader，plugin的区别</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> loader主要用于数据的格式转换</span><br><span class="line">&gt; <span class="number">2.</span> plugin非常强大可以处理包括loader在内的很多事情，常用于导入插件</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="rem根标签是如何计算的"><a href="#rem根标签是如何计算的" class="headerlink" title="rem根标签是如何计算的"></a>rem根标签是如何计算的</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; rem是指根元素（root element，html）的字体大小，从遥远的 IE6 到版本到 Chrome 他们都约好了，根元素默认的 font-size 都是 <span class="number">16</span>px。</span><br><span class="line">&gt; rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小；</span><br><span class="line">&gt; 所以<span class="number">1</span>rem16(这个是html的fontsize)=<span class="number">16</span>px;</span><br><span class="line">&gt; <span class="number">2</span>rem16=<span class="number">32</span>px;</span><br><span class="line">&gt; 要想让rem和px成<span class="number">100</span>倍的关系，即<span class="number">1</span>rem*<span class="number">100</span>=<span class="number">100</span>px；则html的字体大小就应该是<span class="number">100</span>px；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="vuex常用的方法"><a href="#vuex常用的方法" class="headerlink" title="vuex常用的方法"></a>vuex常用的方法</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; VueX 是一个专门为 Vue.js 应用设计的状态管理构架，统一管理和维护各个vue组件的可变化状态(你可以理解成 vue 组件里的某些 data )。</span><br><span class="line">&gt; </span><br><span class="line">&gt; Vuex有五个核心概念：</span><br><span class="line">&gt; state, getters, mutations, actions, modules。</span><br><span class="line">&gt; <span class="number">1.</span> state：vuex的基本数据，用来存储变量</span><br><span class="line">&gt; <span class="number">2.</span> geeter：从基本数据(state)派生的数据，相当于state的计算属性</span><br><span class="line">&gt; <span class="number">3.</span> mutation：提交更新数据的方法，必须是同步的(如果需要异步使用action)。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。</span><br><span class="line">&gt; 回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。</span><br><span class="line">&gt; <span class="number">4.</span> action：和mutation的功能大致相同，不同之处在于 ==》<span class="number">1.</span> Action 提交的是 mutation，而不是直接变更状态。 <span class="number">2.</span> Action 可以包含任意异步操作。</span><br><span class="line">&gt; <span class="number">5.</span> modules：模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="实现图片懒加载"><a href="#实现图片懒加载" class="headerlink" title="实现图片懒加载"></a>实现图片懒加载</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 首先先自定义属性如:data-imgurl,存放着图片的路径，然后通过js判断界面滚动的位置/图片是否已加载，</span><br><span class="line">&gt; 未加载再去获取属性data-imgurl的值赋给src </span><br><span class="line">&gt; <span class="number">1.</span> 加载loading图片</span><br><span class="line">&gt; <span class="number">2.</span> 判断哪些图片要加载【重点】</span><br><span class="line">&gt; <span class="number">3.</span> 隐形加载图片</span><br><span class="line">&gt; <span class="number">4.</span> 替换真图片</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h1><blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 伪类<span class="selector-tag">-</span><span class="selector-pseudo">:active</span> <span class="selector-pseudo">:hover</span> <span class="selector-pseudo">:link</span> <span class="selector-pseudo">:visited</span> <span class="selector-pseudo">:first-child</span> <span class="selector-pseudo">:enable</span> <span class="selector-pseudo">:disable</span> <span class="selector-pseudo">:checked</span> <span class="selector-pseudo">:target</span> <span class="selector-pseudo">:nth-child(n)</span> <span class="selector-pseudo">:last-child</span> <span class="selector-pseudo">:empty</span></span><br><span class="line">&gt; 伪元素<span class="selector-tag">-</span><span class="selector-pseudo">::before</span> <span class="selector-pseudo">::after</span> <span class="selector-pseudo">::first-letter</span> <span class="selector-pseudo">::first-line</span> <span class="selector-pseudo">::selection</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="pop，push，unshift，shift区别"><a href="#pop，push，unshift，shift区别" class="headerlink" title="pop，push，unshift，shift区别"></a>pop，push，unshift，shift区别</h1><blockquote>
<p>依次为数组尾部删除，尾部添加，首部添加，首部删除</p>
</blockquote>
<h1 id="webpack打包后调试"><a href="#webpack打包后调试" class="headerlink" title="webpack打包后调试"></a>webpack打包后调试</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 配置开发环境 devtool：<span class="string">'source-map'</span></span><br><span class="line">&gt; source-map会为每一个打包后的模块生成独立的soucemap .map , 会在 bundle 文件末尾追加 sourceURI= 指定 .map 文件路径，会在浏览器开发者工具中看到webpack:<span class="comment">//的文件夹</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="快速排序和冒泡排序的区别"><a href="#快速排序和冒泡排序的区别" class="headerlink" title="快速排序和冒泡排序的区别"></a>快速排序和冒泡排序的区别</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt; 时间复杂度不同，即运行算法的性能不同，数据越多越复杂，快速排序的优势越大。</span><br><span class="line">&gt; 快排的时间复杂度：nlogn，冒泡：n2</span><br><span class="line">&gt; ******************************************************************</span><br><span class="line">&gt; 快排 :</span><br><span class="line">&gt;     <span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&gt;     <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span>(arr.length&lt;<span class="number">1</span>)&#123;</span><br><span class="line">&gt;             <span class="keyword">return</span> arr</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">var</span> left = []</span><br><span class="line">&gt;         <span class="keyword">var</span> right = []</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>)</span><br><span class="line">&gt;         <span class="keyword">var</span> item = arr.splice(index,<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">&gt;             <span class="keyword">if</span>(arr[i]&lt;item)&#123;</span><br><span class="line">&gt;                 left.push(arr[i])</span><br><span class="line">&gt;             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">&gt;                 right.push(arr[i])</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> quickSort(left).concat([item],quickSort(right))</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">let</span> a = quickSort(arr)</span><br><span class="line">&gt;     <span class="built_in">console</span>.log(a);</span><br><span class="line">&gt; </span><br><span class="line">&gt; ******************************************************************</span><br><span class="line">&gt; 冒泡 :</span><br><span class="line">&gt; 		<span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">321</span>,<span class="number">561</span>,<span class="number">2</span>,<span class="number">31</span>,<span class="number">56</span>,<span class="number">23</span>,<span class="number">10</span>,<span class="number">61</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">31</span>,<span class="number">60</span>,<span class="number">230</span>,<span class="number">23</span>,]   </span><br><span class="line">&gt;         <span class="keyword">var</span> bubbling = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123; <span class="comment">// 冒泡</span></span><br><span class="line">&gt;             <span class="keyword">let</span> len = arr.length<span class="comment">// 取出长度</span></span><br><span class="line">&gt;             <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; len<span class="number">-1</span> ; i++)&#123;<span class="comment">// 遍历</span></span><br><span class="line">&gt;                 <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; len-i<span class="number">-1</span> ; j++)&#123;<span class="comment">// 遍历</span></span><br><span class="line">&gt;                     <span class="keyword">if</span>(arr[j]&lt;arr[j+<span class="number">1</span>])&#123; <span class="comment">// 判断</span></span><br><span class="line">&gt;                         <span class="keyword">let</span> temp = arr[j] <span class="comment">// 取值</span></span><br><span class="line">&gt;                         arr[j] = arr[j+<span class="number">1</span>] <span class="comment">// 交换</span></span><br><span class="line">&gt;                         arr[j+<span class="number">1</span>] = temp</span><br><span class="line">&gt;                     &#125;</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;             <span class="keyword">return</span> arr <span class="comment">// 返回</span></span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="built_in">console</span>.log(bubbling(arr))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="手写深拷贝-amp-浅拷贝"><a href="#手写深拷贝-amp-浅拷贝" class="headerlink" title="手写深拷贝&amp;浅拷贝"></a>手写深拷贝&amp;浅拷贝</h1><p>深拷贝</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="keyword">var</span> obj1 = [&#123;</span><br><span class="line">&gt;         name: <span class="string">'臧三'</span>,</span><br><span class="line">&gt;         childs: [<span class="string">'小明'</span>, <span class="string">'小芳'</span>]</span><br><span class="line">&gt;     &#125;]</span><br><span class="line">&gt;     **************************************************************</span><br><span class="line">&gt;     利用json.stringify</span><br><span class="line">&gt;     <span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1))</span><br><span class="line">&gt;     obj2[<span class="number">0</span>].childs = []</span><br><span class="line">&gt;     <span class="built_in">console</span>.log(obj1, obj2)</span><br><span class="line">&gt;     **************************************************************</span><br><span class="line">&gt;     利用递归来实现一个方法进行拷贝</span><br><span class="line">&gt;     <span class="keyword">var</span> obj3 = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'object'</span> &amp;&amp; data) &#123;</span><br><span class="line">&gt;             <span class="keyword">let</span> val = <span class="keyword">typeof</span> data.length === <span class="string">'number'</span> ? [] : &#123;&#125;</span><br><span class="line">&gt;             <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> data) &#123;</span><br><span class="line">&gt;                 val[i] = obj3(data[i])</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;             <span class="keyword">return</span> val</span><br><span class="line">&gt;         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;             <span class="keyword">return</span> data</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125; </span><br><span class="line">&gt;     **************************************************************</span><br><span class="line">&gt;     利用instanceOf</span><br><span class="line">&gt;     <span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">newObj,obj</span>)</span>&#123;</span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">&gt;             <span class="keyword">if</span>( obj[key]  <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">&gt;                 newObj[key] = []</span><br><span class="line">&gt;                 copy(newObj[key],obj[key])</span><br><span class="line">&gt;             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj[key]  <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</span><br><span class="line">&gt;                 newObj[key] = &#123;&#125;</span><br><span class="line">&gt;                 copy(newObj[key],obj[key])</span><br><span class="line">&gt;             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">&gt;                 newObj[key]=obj[key]</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>浅拷贝</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.</span> 利用<span class="built_in">Object</span>.assign()</span><br><span class="line">&gt; <span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line">&gt; <span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1)</span><br><span class="line">&gt; obj2.a = <span class="number">4</span></span><br><span class="line">&gt; <span class="built_in">console</span>.log(obj1, obj2)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">2.</span> 利用解构赋值</span><br><span class="line">&gt; <span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line">&gt; <span class="keyword">var</span> obj2 = &#123;...obj1&#125;</span><br><span class="line">&gt; obj2.a = <span class="number">4</span></span><br><span class="line">&gt; <span class="built_in">console</span>.log(obj1, obj2)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>区别</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用，</span><br><span class="line">&gt; 深拷贝在计算机中开辟了一块内存地址用于存放复制的对象，而浅拷贝仅仅是指向被拷贝的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="块级元素和行内元素区别"><a href="#块级元素和行内元素区别" class="headerlink" title="块级元素和行内元素区别"></a>块级元素和行内元素区别</h1><p><code>块级元素</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt; 每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素；</span><br><span class="line">&gt; </span><br><span class="line">&gt; 块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如&lt;form&gt;只能包含块级元素。其他的块级元素则可以包含 行级元素如&lt;P&gt;.也有一些则既可以包含块级，也可以包含行级元素。</span><br><span class="line">&gt; </span><br><span class="line">&gt; DIV 是最常用的块级元素，元素样式的display:block都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 特点 :</span><br><span class="line">&gt; ①、总是在新行上开始；</span><br><span class="line">&gt; ②、高度，行高以及外边距和内边距都可控制；</span><br><span class="line">&gt; ③、宽度缺省是它的容器的<span class="number">100</span>%，除非设定一个宽度。</span><br><span class="line">&gt; ④、它可以容纳内联元素和其他块元素</span><br><span class="line">&gt; </span><br><span class="line">&gt; 常见块级元素 :</span><br><span class="line">&gt; address – 地址</span><br><span class="line">&gt; blockquote – 块引用</span><br><span class="line">&gt; center – 举中对齐块</span><br><span class="line">&gt; dir – 目录列表</span><br><span class="line">&gt; div – 常用块级容易，也是CSS layout的主要标签</span><br><span class="line">&gt; dl – 定义列表</span><br><span class="line">&gt; fieldset – form控制组</span><br><span class="line">&gt; form – 交互表单</span><br><span class="line">&gt; h1 – 大标题</span><br><span class="line">&gt; h2 – 副标题</span><br><span class="line">&gt; h3 – <span class="number">3</span>级标题</span><br><span class="line">&gt; h4 – <span class="number">4</span>级标题</span><br><span class="line">&gt; h5 – <span class="number">5</span>级标题</span><br><span class="line">&gt; h6 – <span class="number">6</span>级标题</span><br><span class="line">&gt; hr – 水平分隔线</span><br><span class="line">&gt; isindex – input prompt</span><br><span class="line">&gt; menu – 菜单列表</span><br><span class="line">&gt; noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容</span><br><span class="line">&gt; noscript – 可选脚本内容（对于不支持script的浏览器显示此内容）</span><br><span class="line">&gt; ol – 有序表单</span><br><span class="line">&gt; p – 段落</span><br><span class="line">&gt; pre – 格式化文本</span><br><span class="line">&gt; table – 表格</span><br><span class="line">&gt; ul – 无序列表</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>行内元素</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&gt; 也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 SPAN 元素，IFRAME元素和元素样式的display : inline的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 特点 :</span><br><span class="line">&gt; ①、和其他元素都在一行上；</span><br><span class="line">&gt; ②、高，行高及外边距和内边距不可改变；</span><br><span class="line">&gt; ③、宽度就是它的文字或图片的宽度，不可改变</span><br><span class="line">&gt; ④、内联元素只能容纳文本或者其他内联元素</span><br><span class="line">&gt; </span><br><span class="line">&gt; 注意 :</span><br><span class="line">&gt; 设置宽度width 无效。</span><br><span class="line">&gt; 设置高度height 无效，可以通过line-height来设置。</span><br><span class="line">&gt; 设置margin 只有左右margin有效，上下无效。</span><br><span class="line">&gt; 设置padding 只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 常见行内元素 :</span><br><span class="line">&gt; a – 锚点</span><br><span class="line">&gt; abbr – 缩写</span><br><span class="line">&gt; acronym – 首字</span><br><span class="line">&gt; b – 粗体(不推荐)</span><br><span class="line">&gt; bdo – bidi override</span><br><span class="line">&gt; big – 大字体</span><br><span class="line">&gt; br – 换行</span><br><span class="line">&gt; cite – 引用</span><br><span class="line">&gt; code – 计算机代码(在引用源码的时候需要)</span><br><span class="line">&gt; dfn – 定义字段</span><br><span class="line">&gt; em – 强调</span><br><span class="line">&gt; font – 字体设定(不推荐)</span><br><span class="line">&gt; i – 斜体</span><br><span class="line">&gt; img – 图片</span><br><span class="line">&gt; input – 输入框</span><br><span class="line">&gt; kbd – 定义键盘文本</span><br><span class="line">&gt; label – 表格标签</span><br><span class="line">&gt; q – 短引用</span><br><span class="line">&gt; s – 中划线(不推荐)</span><br><span class="line">&gt; samp – 定义范例计算机代码</span><br><span class="line">&gt; select – 项目选择</span><br><span class="line">&gt; small – 小字体文本</span><br><span class="line">&gt; span – 常用内联容器，定义文本内区块</span><br><span class="line">&gt; strike – 中划线</span><br><span class="line">&gt; strong – 粗体强调</span><br><span class="line">&gt; sub – 下标</span><br><span class="line">&gt; sup – 上标</span><br><span class="line">&gt; textarea – 多行文本输入框</span><br><span class="line">&gt; tt – 电传文本</span><br><span class="line">&gt; u – 下划线</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>区别</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区别一：</span><br><span class="line">&gt; </span><br><span class="line">&gt;     块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度</span><br><span class="line">&gt;     行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 区别二：</span><br><span class="line">&gt; </span><br><span class="line">&gt;     块级：块级元素可以设置宽高</span><br><span class="line">&gt;     行内：行内元素不可以设置宽高</span><br><span class="line">&gt; </span><br><span class="line">&gt; 区别三：</span><br><span class="line">&gt; </span><br><span class="line">&gt;     块级：块级元素可以设置margin，padding</span><br><span class="line">&gt;     行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 区别四：</span><br><span class="line">&gt; </span><br><span class="line">&gt;     块级：display:block;</span><br><span class="line">&gt;     行内：display:inline;</span><br><span class="line">&gt; </span><br><span class="line">&gt; 可以通过修改display属性来切换块级元素和行内元素</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="元素不定宽高垂直居中"><a href="#元素不定宽高垂直居中" class="headerlink" title="元素不定宽高垂直居中"></a>元素不定宽高垂直居中</h1><ol>
<li><code>display:table和diaplay:table-cell</code></li>
</ol>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">&gt; <span class="selector-class">.container</span> &#123;</span><br><span class="line">&gt;   display: table;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="selector-class">.inner</span> &#123;</span><br><span class="line">&gt;   display: table-cell;</span><br><span class="line">&gt;   <span class="selector-tag">vertical-align</span><span class="selector-pseudo">:middle</span>;</span><br><span class="line">&gt;   <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &lt;/style&gt;</span><br><span class="line">&gt; &lt;div class="container"&gt;</span><br><span class="line">&gt;   &lt;div class="inner"&gt;</span><br><span class="line">&gt;   <span class="selector-tag">you</span> <span class="selector-tag">own</span> <span class="selector-tag">content</span></span><br><span class="line">&gt;   &lt;/div&gt;</span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><code>position:absolute、50%和translate</code></li>
</ol>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">&gt; <span class="selector-class">.container</span> &#123;</span><br><span class="line">&gt;   position: relative;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="selector-class">.inner</span> &#123;</span><br><span class="line">&gt;   position: absolute;</span><br><span class="line">&gt;   <span class="selector-tag">top</span>: 50%;</span><br><span class="line">&gt;   <span class="selector-tag">left</span>: 50%;</span><br><span class="line">&gt;   <span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(<span class="selector-tag">-50</span>%, <span class="selector-tag">-50</span>%);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &lt;/style&gt;</span><br><span class="line">&gt; &lt;div class="container"&gt;</span><br><span class="line">&gt;   &lt;div class="inner"&gt;</span><br><span class="line">&gt;     <span class="selector-tag">your</span> <span class="selector-tag">own</span> <span class="selector-tag">content</span></span><br><span class="line">&gt;   &lt;/div&gt;</span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><code>vw vh和translate</code></li>
</ol>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">&gt; <span class="selector-class">.inner</span> &#123;</span><br><span class="line">&gt;    position:fixed;</span><br><span class="line">&gt;    <span class="selector-tag">top</span>: 50<span class="selector-tag">vh</span>;</span><br><span class="line">&gt;    <span class="selector-tag">left</span>: 50<span class="selector-tag">vw</span>;</span><br><span class="line">&gt;    <span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(<span class="selector-tag">-50</span>%, <span class="selector-tag">-50</span>%); </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &lt;/style&gt;</span><br><span class="line">&gt; &lt;div class="inner"&gt;</span><br><span class="line">&gt;   <span class="selector-tag">this</span> <span class="selector-tag">is</span> <span class="selector-tag">a</span> <span class="selector-tag">box</span> <span class="selector-tag">fixed</span> <span class="selector-tag">in</span> <span class="selector-tag">center</span> <span class="selector-tag">of</span> <span class="selector-tag">screen</span></span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><code>:before和display:inline-block</code></li>
</ol>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">&gt; <span class="selector-class">.container</span>&#123;</span><br><span class="line">&gt;     text-align: center;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="selector-class">.container</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">&gt;     content: '';</span><br><span class="line">&gt;     <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line">&gt;     <span class="selector-tag">height</span>: 100%;</span><br><span class="line">&gt;     <span class="selector-tag">vertical-align</span>: <span class="selector-tag">middle</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="selector-class">.inner</span> &#123;</span><br><span class="line">&gt;     display: inline-block;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &lt;/style&gt;</span><br><span class="line">&gt; &lt;div class="container"&gt;</span><br><span class="line">&gt;     &lt;div class="inner"&gt;</span><br><span class="line">&gt;         <span class="selector-tag">this</span> <span class="selector-tag">is</span> <span class="selector-tag">a</span> <span class="selector-tag">box</span> <span class="selector-tag">fixed</span> <span class="selector-tag">in</span> <span class="selector-tag">center</span> <span class="selector-tag">of</span> <span class="selector-tag">screen</span>&lt;<span class="selector-tag">br</span>&gt;<span class="selector-tag">The</span> <span class="selector-tag">second</span> <span class="selector-tag">line</span></span><br><span class="line">&gt;     &lt;/div&gt;</span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="对闭包的看法"><a href="#对闭包的看法" class="headerlink" title="对闭包的看法"></a>对闭包的看法</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; 要理解闭包，首先必须理解Javascript特殊的变量作用域。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 变量的作用域无非就是两种：全局变量和局部变量。</span><br><span class="line">&gt; </span><br><span class="line">&gt; Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 另一方面，在函数外部自然无法读取函数内的局部变量。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用<span class="keyword">var</span>命令。如果不用的话，你实际上声明了一个全局变量</span><br><span class="line">&gt; </span><br><span class="line">&gt; 出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 那就是在函数的内部，再定义一个函数</span><br><span class="line">&gt; </span><br><span class="line">&gt; 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 注意 :</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">1</span>）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">2</span>）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。	</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在ES6之前，JavaScript没有块级作用域(一对花括号&#123;&#125;即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 引擎在读取js代码的过程中，分为两步。第一个步骤是整个js代码的解析读取，第二个步骤是执行。 </span><br><span class="line">&gt; </span><br><span class="line">&gt; 在读取代码的过程中，就产生了将所有声明提升到顶端，然后再从上往下执行。由此产生了变量提升和函数提升。</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">1.</span>变量提升只会提升变量名的声明，而不会提升变量的赋值初始化，同理，函数声明也是如此。</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">2.</span>函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h1><p><code>减少请求数量</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; 【合并】</span><br><span class="line">&gt; 　　如果不进行文件合并，有如下<span class="number">3</span>个隐患</span><br><span class="line">&gt; 　　<span class="number">1</span>、文件与文件之间有插入的上行请求，增加了N<span class="number">-1</span>个网络延迟</span><br><span class="line">&gt; 　　<span class="number">2</span>、受丢包问题影响更严重</span><br><span class="line">&gt; 　　<span class="number">3</span>、经过代理服务器时可能会被断开</span><br><span class="line">&gt; 　　但是，文件合并本身也有自己的问题</span><br><span class="line">&gt; 　　<span class="number">1</span>、首屏渲染问题</span><br><span class="line">&gt; 　　<span class="number">2</span>、缓存失效问题</span><br><span class="line">&gt; 　　所以，对于文件合并，有如下改进建议</span><br><span class="line">&gt; 　　<span class="number">1</span>、公共库合并</span><br><span class="line">&gt; 　　<span class="number">2</span>、不同页面单独合并</span><br><span class="line">&gt; 【图片处理】</span><br><span class="line">&gt; 　　<span class="number">1</span>、雪碧图</span><br><span class="line">&gt; 　　CSS雪碧图是以前非常流行的技术，把网站上的一些图片整合到一张单独的图片中，可以减少网站的HTTP请求数量，但是当整合图片比较大时，一次加载比较慢。随着字体图片、SVG图片的流行，该技术渐渐退出了历史舞台</span><br><span class="line">&gt; 　　<span class="number">2</span>、Base64</span><br><span class="line">&gt; 　　将图片的内容以Base64格式内嵌到HTML中，可以减少HTTP请求数量。但是，由于Base64编码用<span class="number">8</span>位字符表示信息中的<span class="number">6</span>个位，所以编码后大小大约比原始值扩大了 <span class="number">33</span>%</span><br><span class="line">&gt; 　　<span class="number">3</span>、使用字体图标来代替图片</span><br><span class="line">&gt; 【减少重定向】</span><br><span class="line">&gt; 　　尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验</span><br><span class="line">&gt; 　　如果一定要使用重定向，如http重定向到https，要使用<span class="number">301</span>永久重定向，而不是<span class="number">302</span>临时重定向。因为，如果使用<span class="number">302</span>，则每一次访问http，都会被重定向到https的页面。而永久重定向，在第一次从http重定向到https之后 ，每次访问http，会直接返回https的页面</span><br><span class="line">&gt; 【使用缓存】</span><br><span class="line">&gt; 　　使用cach-control或expires这类强缓存时，缓存不过期的情况下，不向服务器发送请求。强缓存过期时，会使用last-modified或etag这类协商缓存，向服务器发送请求，如果资源没有变化，则服务器返回<span class="number">304</span>响应，浏览器继续从本地缓存加载资源；如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回<span class="number">200</span>响应</span><br><span class="line">&gt; 【不使用CSS @<span class="keyword">import</span>】</span><br><span class="line">&gt; 　　CSS的@<span class="keyword">import</span>会造成额外的请求</span><br><span class="line">&gt; 【避免使用空的src和href】</span><br><span class="line">&gt; 　　a标签设置空的href，会重定向到当前的页面地址</span><br><span class="line">&gt; 　　form设置空的method，会提交表单到当前的页面地址</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>减小资源大小</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; 【压缩】</span><br><span class="line">&gt; 　　<span class="number">1</span>、HTML压缩</span><br><span class="line">&gt;       HTML代码压缩就是压缩在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等</span><br><span class="line">&gt; 　　<span class="number">2</span>、CSS压缩</span><br><span class="line">&gt;       CSS压缩包括无效代码删除与CSS语义合并</span><br><span class="line">&gt; 　　<span class="number">3</span>、JS压缩与混乱</span><br><span class="line">&gt;       JS压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码可读性，实现代码保护</span><br><span class="line">&gt; 　　<span class="number">4</span>、图片压缩</span><br><span class="line">&gt;       针对真实图片情况，舍弃一些相对无关紧要的色彩信息</span><br><span class="line">&gt; 【webp】</span><br><span class="line">&gt; 　　在安卓下可以使用webp格式的图片，它具有更优的图像数据压缩算法，能带来更小的图片体积，同等画面质量下，体积比jpg、png少了<span class="number">25</span>%以上，而且同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性</span><br><span class="line">&gt; 【开启gzip】</span><br><span class="line">&gt; 　　HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来。一般对纯文本内容可压缩到原大小的<span class="number">40</span>%</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>优化网络连接</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; 【使用CDN】</span><br><span class="line">&gt; 　　CDN全称是Content Delivery Network，即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度</span><br><span class="line">&gt; 【使用DNS预解析】</span><br><span class="line">&gt; 　　当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址</span><br><span class="line">&gt; 　　DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度</span><br><span class="line">&gt; 　　方法是在 head 标签里面写上几个 link 标签</span><br><span class="line">&gt; 【并行连接】</span><br><span class="line">&gt; 　　由于在HTTP1<span class="number">.1</span>协议下，chrome每个域名的最大并发数是<span class="number">6</span>个。使用多个域名，可以增加并发数</span><br><span class="line">&gt; 【持久连接】</span><br><span class="line">&gt; 　　使用keep-alive或presistent来建立持久连接，持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量</span><br><span class="line">&gt; 【管道化连接】</span><br><span class="line">&gt; 　　在HTTP2协议中，可以开启管道化连接，即单条连接的多路复用，每条连接中并发传输多个资源，这里就不需要添加域名来增加并发数了</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>优化资源加载</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; 【资源加载位置】</span><br><span class="line">&gt; 　　通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用</span><br><span class="line">&gt; 　　<span class="number">1</span>、CSS文件放在head中，先外链，后本页</span><br><span class="line">&gt; 　　<span class="number">2</span>、JS文件放在body底部，先外链，后本页</span><br><span class="line">&gt; 　　<span class="number">3</span>、处理页面、处理页面布局的JS文件放在head中，如babel-polyfill.js文件、flexible.js文件</span><br><span class="line">&gt; 　　<span class="number">4</span>、body中间尽量不写style标签和script标签</span><br><span class="line">&gt; 【资源加载时机】</span><br><span class="line">&gt; 　　<span class="number">1</span>、异步script标签</span><br><span class="line">&gt;       defer:  异步加载，在HTML解析完成后执行。defer的实际效果与将代码放在body底部类似</span><br><span class="line">&gt;       <span class="keyword">async</span>: 异步加载，加载完成后立即执行</span><br><span class="line">&gt; 　　<span class="number">2</span>、模块按需加载</span><br><span class="line">&gt;       在SPA等业务逻辑比较复杂的系统中，需要根据路由来加载当前页面需要的业务模块</span><br><span class="line">&gt;       按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载</span><br><span class="line">&gt;       webpack 提供了两个类似的技术，优先选择的方式是使用符合 ECMAScript 提案 的 <span class="keyword">import</span>() 语法。第二种则是使用 webpack 特定的 <span class="built_in">require</span>.ensure</span><br><span class="line">&gt; 　　<span class="number">3</span>、使用资源预加载preload和资源预读取prefetch</span><br><span class="line">&gt;       preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度</span><br><span class="line">&gt;       prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度</span><br><span class="line">&gt; 　　<span class="number">4</span>、资源懒加载与资源预加载</span><br><span class="line">&gt;       资源延迟加载也称为懒加载，延迟加载资源或符合某些条件时才加载某些资源</span><br><span class="line">&gt;       资源预加载是提前加载用户所需的资源，保证良好的用户体验</span><br><span class="line">&gt;       资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不做操作，浏览器空间时，再加载资源，优化了网络性能</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>减少重绘回流</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; 【样式设置】</span><br><span class="line">&gt; 　　<span class="number">1</span>、避免使用层级较深的选择器，或其他一些复杂的选择器，以提高CSS渲染效率</span><br><span class="line">&gt; 　　<span class="number">2</span>、避免使用CSS表达式，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次</span><br><span class="line">&gt; 　　<span class="number">3</span>、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流</span><br><span class="line">&gt; 　　<span class="number">4</span>、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从<span class="number">0</span>到完全出现，上下左右都可能位移，发生回流</span><br><span class="line">&gt; 　　<span class="number">5</span>、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要<span class="number">3</span>倍于同等元素时间</span><br><span class="line">&gt; 　　<span class="number">6</span>、能够使用CSS实现的效果，尽量使用CSS而不使用JS实现</span><br><span class="line">&gt; 【渲染层】</span><br><span class="line">&gt; 　　<span class="number">1</span>、此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围</span><br><span class="line">&gt; 　　<span class="number">2</span>、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流</span><br><span class="line">&gt; 【DOM优化】</span><br><span class="line">&gt; 　　<span class="number">1</span>、缓存DOM</span><br><span class="line">&gt;         <span class="keyword">const</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>)</span><br><span class="line">&gt;       由于查询DOM比较耗时，在同一个节点无需多次查询的情况下，可以缓存DOM</span><br><span class="line">&gt; 　　<span class="number">2</span>、减少DOM深度及DOM数量</span><br><span class="line">&gt;       HTML 中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。</span><br><span class="line">&gt; 　　<span class="number">3</span>、批量操作DOM</span><br><span class="line">&gt;       由于DOM操作比较耗时，且可能会造成回流，因此要避免频繁操作DOM，可以批量操作DOM，先用字符串拼接完毕，再用innerHTML更新DOM</span><br><span class="line">&gt; 　　<span class="number">4</span>、批量操作CSS样式</span><br><span class="line">&gt;       通过切换<span class="class"><span class="keyword">class</span>或者使用元素的<span class="title">style</span>.<span class="title">csstext</span>属性去批量操作元素样式</span></span><br><span class="line"><span class="class">&gt; 　　5、在内存中操作<span class="title">DOM</span></span></span><br><span class="line"><span class="class">&gt;       使用<span class="title">DocumentFragment</span>对象，让<span class="title">DOM</span>操作发生在内存中，而不是页面上</span></span><br><span class="line"><span class="class">&gt; 　　6、<span class="title">DOM</span>元素离线更新</span></span><br><span class="line">&gt;       对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作</span><br><span class="line">&gt; 　　<span class="number">7</span>、DOM读写分离</span><br><span class="line">&gt;       浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行</span><br><span class="line">&gt; 　　<span class="number">8</span>、事件代理</span><br><span class="line">&gt;       事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件</span><br><span class="line">&gt;       利用事件代理，可以减少内存使用，提高性能及降低代码复杂度</span><br><span class="line">&gt; 　　<span class="number">9</span>、防抖和节流</span><br><span class="line">&gt;       使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发</span><br><span class="line">&gt; 　　<span class="number">10</span>、及时清理环境</span><br><span class="line">&gt;       及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>性能更好的API</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; 	<span class="number">1</span>、用对选择器</span><br><span class="line">&gt;       选择器的性能排序如下所示，尽量选择性能更好的选择器</span><br><span class="line">&gt;         id选择器（#myid）</span><br><span class="line">&gt;         类选择器（.myclassname）</span><br><span class="line">&gt;         标签选择器（div,h1,p）</span><br><span class="line">&gt;         相邻选择器（h1+p）</span><br><span class="line">&gt;         子选择器（ul &gt; li）</span><br><span class="line">&gt;         后代选择器（li a）</span><br><span class="line">&gt;         通配符选择器（*）</span><br><span class="line">&gt;         属性选择器（a[rel=<span class="string">"external"</span>]）</span><br><span class="line">&gt;         伪类选择器（a:hover,<span class="attr">li</span>:nth-child）</span><br><span class="line">&gt; 　　<span class="number">2</span>、使用requestAnimationFrame来替代setTimeout和setInterval</span><br><span class="line">&gt;       希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用 setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧</span><br><span class="line">&gt; 　　<span class="number">3</span>、使用IntersectionObserver来实现图片可视区域的懒加载</span><br><span class="line">&gt;       传统的做法中，需要使用scroll事件，并调用getBoundingClientRect方法，来实现可视区域的判断，即使使用了函数节流，也会造成页面回流。使用IntersectionObserver，则没有上述问题</span><br><span class="line">&gt; 　　<span class="number">4</span>、使用web worker</span><br><span class="line">&gt;       客户端javascript一个基本的特性是单线程：比如，浏览器无法同时运行两个事件处理程序，它也无法在一个事件处理程序运行的时候触发一个计时器。Web Worker是HTML5提供的一个javascript多线程解决方案，可以将一些大计算量的代码交由web Worker运行，从而避免阻塞用户界面，在执行复杂计算和数据处理时，这个API非常有用</span><br><span class="line">&gt; 　　但是，使用一些新的API的同时，也要注意其浏览器兼容性</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>webpack优化</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; 【打包公共代码】</span><br><span class="line">&gt; 　　使用CommonsChunkPlugin插件，将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件</span><br><span class="line">&gt; 　　webpack <span class="number">4</span> 将移除 CommonsChunkPlugin, 取而代之的是两个新的配置项 optimization.splitChunks 和 optimization.runtimeChunk</span><br><span class="line">&gt; 　　通过设置 optimization.splitChunks.chunks: <span class="string">"all"</span> 来启动默认的代码分割配置项</span><br><span class="line">&gt; 【动态导入和按需加载】</span><br><span class="line">&gt; 　　webpack提供了两种技术通过模块的内联函数调用来分离代码，优先选择的方式是，使用符合 ECMAScript 提案 的 <span class="keyword">import</span>() 语法。第二种，则是使用 webpack 特定的 <span class="built_in">require</span>.ensure</span><br><span class="line">&gt; 【剔除无用代码】</span><br><span class="line">&gt; 　　tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 <span class="keyword">import</span> 和 <span class="keyword">export</span>。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup</span><br><span class="line">&gt; 　　JS的tree shaking主要通过uglifyjs插件来完成，CSS的tree shaking主要通过purify CSS来实现的</span><br><span class="line">&gt; 【长缓存优化】</span><br><span class="line">&gt; 　　<span class="number">1</span>、将hash替换为chunkhash，这样当chunk不变时，缓存依然有效</span><br><span class="line">&gt; 　　<span class="number">2</span>、使用Name而不是id</span><br><span class="line">&gt; 　　每个 <span class="built_in">module</span>.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变</span><br><span class="line">&gt; 　　下面来使用两个插件解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建</span><br><span class="line">&gt; 【公用代码内联】</span><br><span class="line">&gt; 　　使用html-webpack-inline-chunk-plugin插件将mainfest.js内联到html文件中</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="前端seo优化"><a href="#前端seo优化" class="headerlink" title="前端seo优化"></a>前端seo优化</h1><p>通过网站的结构布局设计和网页代码优化，使前端页面既能让浏览器用户能够看懂，也能让“蜘蛛”看懂</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="number">1</span>) 网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。</span><br><span class="line">&gt; </span><br><span class="line">&gt;     一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。一般中小型网站目录结构超过三级，“蜘蛛”便不愿意往下爬，“万一天黑迷路了怎么办”。并且根据相关调查：访客如果经过跳转<span class="number">3</span>次还没找到需要的信息，很可能离开。因此，三层目录结构也是体验的需要。为此我们需要做到：</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="number">1.</span> 控制首页链接数量</span><br><span class="line">&gt;         网站首页是权重最高的地方，如果首页链接太少，没有“桥”，“蜘蛛”不能继续往下爬到内页，直接影响网站收录数量。但是首页链接也不能太多，一旦太多，没有实质性的链接，很容易影响用户体验，也会降低网站首页的权重，收录效果也不好。</span><br><span class="line">&gt;         因此对于中小型企业网站，建议首页链接在<span class="number">100</span>个以内，链接的性质可以包含页面导航、底部导航、锚文字链接等等，注意链接要建立在用户的良好体验和引导用户获取信息的基础之上。</span><br><span class="line">&gt;     <span class="number">2.</span>扁平化的目录层次，尽量让“蜘蛛”只要跳转<span class="number">3</span>次，就能到达网站内的任何一个内页。扁平化的目录结构，比如：“植物”–&gt; “水果” –&gt; “苹果”、“桔子”、“香蕉”，通过<span class="number">3</span>级就能找到香蕉了。</span><br><span class="line">&gt;     <span class="number">3.</span>导航优化</span><br><span class="line">&gt;         导航应该尽量采用文字方式，也可以搭配图片导航，但是图片代码一定要进行优化，&lt;img&gt;标签必须添加“alt”和“title”属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字。</span><br><span class="line">&gt;         其次，在每一个网页上应该加上面包屑导航，好处：从用户体验方面来说，可以让用户了解当前所处的位置以及当前页面在整个网站中的位置，帮助用户很快了解网站组织形式，从而形成更好的位置感，同时提供了返回各个页面的接口，方便用户操作；对“蜘蛛”而言，能够清楚的了解网站结构，同时还增加了大量的内部链接，方便抓取，降低跳出率。</span><br><span class="line">&gt;     <span class="number">4.</span> 网站的结构布局–不可忽略的细节</span><br><span class="line">&gt;         <span class="number">1</span>）页面头部：logo及主导航，以及用户的信息。</span><br><span class="line">&gt;         <span class="number">2</span>）页面主体：左边正文，包括面包屑导航及正文；右边放热门文章及相关文章，好处：留住访客，让访客多停留，对“蜘蛛”而言，这些文章属于相关链接，增强了页面相关性，也能增强页面的权重。</span><br><span class="line">&gt;         <span class="number">3</span>）页面底部：版权信息和友情链接。</span><br><span class="line">&gt;         特别注意：分页导航写法，推荐写法：“首页 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> 下拉框”，这样“蜘蛛”能够根据相应页码直接跳转，下拉框直接选择页面跳转。而下面的写法是不推荐的，“首页 下一页 尾页”，特别是当分页数量特别多时，“蜘蛛”需要经过很多次往下爬，才能抓取，会很累、会容易放弃。</span><br><span class="line">&gt;     <span class="number">5.</span>控制页面的大小，减少http请求，提高网站的加载速度。</span><br><span class="line">&gt;         一个页面最好不要超过<span class="number">100</span>k，太大，页面加载速度慢。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“蜘蛛”也会离开。</span><br><span class="line">&gt; (<span class="number">2</span>) 网页代码优化</span><br><span class="line">&gt;     <span class="number">1.</span>&lt;title&gt;标题：只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的&lt;title&gt;标题中不要设置相同的内容。</span><br><span class="line">&gt;     <span class="number">2.</span>&lt;meta keywords&gt;标签：关键词，列举出几个页面的重要关键字即可，切记过分堆砌。</span><br><span class="line">&gt;     <span class="number">3.</span>&lt;meta description&gt;标签：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。</span><br><span class="line">&gt;     <span class="number">4.</span>&lt;body&gt;中的标签：尽量让代码语义化，在适当的位置使用适当的标签，用正确的标签做正确的事。让阅读源码者和“蜘蛛”都一目了然。比如：h1-h6是用于标题类的，&lt;nav&gt;标签是用来设置页面主导航的等。</span><br><span class="line">&gt;     <span class="number">5.</span>&lt;a&gt;标签：页内链接，要加“title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上el=<span class="string">"nofollow"</span>属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。</span><br><span class="line">&gt;     <span class="number">6.</span>正文标题要用&lt;h1&gt;标签：“蜘蛛” 认为它最重要，若不喜欢&lt;h1&gt;的默认样式可以通过CSS设置。尽量做到正文标题用&lt;h1&gt;标签，副标题用&lt;h2&gt;标签, 而其它地方不应该随便乱用 h 标题标签。</span><br><span class="line">&gt;     <span class="number">7.</span>&lt;br&gt;标签：只用于文本内容的换行</span><br><span class="line">&gt;     <span class="number">8.</span>表格应该使用&lt;caption&gt;表格标题标签</span><br><span class="line">&gt;     <span class="number">9.</span>&lt;img&gt;应使用 “alt” 属性加以说明</span><br><span class="line">&gt;     <span class="number">10.</span>&lt;strong&gt;、&lt;em&gt;标签 : 需要强调时使用。&lt;strong&gt;标签在搜索引擎中能够得到高度的重视，它能突出关键词，表现重要的内容，&lt;em&gt;标签强调效果仅次于&lt;strong&gt;标签。</span><br><span class="line">&gt;     &lt;b&gt;、&lt;i&gt;标签: 只是用于显示效果时使用，在SEO中不会起任何效果。</span><br><span class="line">&gt;     11、文本缩进不要使用特殊符号&amp;nbsp; 应当使用CSS进行设置。版权符号不要使用特殊符号 &amp;copy; 可以直接使用输入法，拼“banquan”，选择序号5就能打出版权符号©。</span><br><span class="line">&gt;     12、巧妙利用CSS布局，将重要内容的HTML代码放在最前面，最前面的内容被认为是最重要的，优先让“蜘蛛”读取，进行内容关键词抓取。</span><br><span class="line">&gt;     13.重要内容不要用JS输出，因为“蜘蛛”不认识</span><br><span class="line">&gt;     14.尽量少使用iframe框架,因为“蜘蛛”一般不会读取其中的内容</span><br><span class="line">&gt;     15.谨慎使用display：none ：对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。因为搜索引擎会过滤掉display:none其中的内容。</span><br><span class="line">&gt;     16. 不断精简代码</span><br><span class="line">&gt;     17.js代码如果是操作DOM操作，应尽量放在body结束标签之前，html代码之后。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p><code>场景</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</span><br><span class="line">&gt; </span><br><span class="line">&gt; 当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>非同源限制</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【<span class="number">1</span>】无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</span><br><span class="line">【<span class="number">2</span>】无法接触非同源网页的 DOM</span><br><span class="line">【<span class="number">3</span>】无法向非同源地址发送 AJAX 请求</span><br></pre></td></tr></table></figure>

<p><code>方案</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; 【<span class="number">1</span>】设置<span class="built_in">document</span>.domain解决无法读取非同源网页的 Cookie问题</span><br><span class="line">&gt;     因为浏览器是通过<span class="built_in">document</span>.domain属性来检查两个页面是否同源，因此只要通过设置相同的<span class="built_in">document</span>.domain，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）</span><br><span class="line">&gt; </span><br><span class="line">&gt; 【<span class="number">2</span>】跨文档通信 API：<span class="built_in">window</span>.postMessage()</span><br><span class="line">&gt;     调用postMessage方法实现父窗口http:<span class="comment">//test1.com向子窗口http://test2.com发消息（子窗口同样可以通过该方法发送消息给父窗口）</span></span><br><span class="line">&gt;     它可用于解决以下方面的问题：</span><br><span class="line">&gt;         页面和其打开的新窗口的数据传递</span><br><span class="line">&gt;         多窗口之间消息传递</span><br><span class="line">&gt;         页面与嵌套的iframe消息传递</span><br><span class="line">&gt;         上面三个场景的跨域数据传递</span><br><span class="line">&gt;         </span><br><span class="line">&gt; 【<span class="number">3</span>】JSONP</span><br><span class="line">&gt;     JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持<span class="keyword">get</span>请求，不支持post请求。</span><br><span class="line">&gt;     核心思想：网页通过添加一个&lt;script&gt;元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。</span><br><span class="line">&gt;     </span><br><span class="line">&gt; 【4】CORS</span><br><span class="line">&gt;     CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。</span><br><span class="line">&gt;     1、普通跨域请求：只需服务器端设置Access-Control-Allow-Origin</span><br><span class="line">&gt;     2、带cookie跨域请求：前后端都需要进行设置</span><br><span class="line">&gt;     【前端设置】根据xhr.withCredentials字段判断是否带有cookie</span><br><span class="line">&gt;     【服务端设置】</span><br><span class="line">&gt;     服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="JSONP的实现原理"><a href="#JSONP的实现原理" class="headerlink" title="JSONP的实现原理"></a>JSONP的实现原理</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jsonp的本质是利用script标签的src属性进行跨域请求，只能用于<span class="keyword">get</span>请求。</span><br><span class="line">jsonp是请求之后后台包装好一段json，并且把数据放在一个callback函数，返回一个js文件，动态引入这个文件，下载完成js之后，会去调用这个callback,通过这样访问数据。</span><br></pre></td></tr></table></figure>

<h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span> 数字：^[<span class="number">0</span><span class="number">-9</span>]*$</span><br><span class="line">&gt; <span class="number">2</span> n位的数字：^\d&#123;n&#125;$</span><br><span class="line">&gt; <span class="number">3</span> 至少n位的数字：^\d&#123;n,&#125;$</span><br><span class="line">&gt; <span class="number">4</span> m-n位的数字：^\d&#123;m,n&#125;$</span><br><span class="line">&gt; <span class="number">5</span> 零和非零开头的数字：^(<span class="number">0</span>|[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)$</span><br><span class="line">&gt; <span class="number">6</span> 非零开头的最多带两位小数的数字：^([<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line">&gt; <span class="number">7</span> 带<span class="number">1</span><span class="number">-2</span>位小数的正数或负数：^(\-)?\d+(\.\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line">&gt; <span class="number">8</span> 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line">&gt; <span class="number">9</span> 有两位小数的正实数：^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;)?$</span><br><span class="line">&gt; <span class="number">10</span> 有<span class="number">1</span>~<span class="number">3</span>位小数的正实数：^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)?$</span><br><span class="line">&gt; <span class="number">11</span> 非零的正整数：^[<span class="number">1</span><span class="number">-9</span>]\d*$ 或 ^([<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;$ 或 ^\+?[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*$</span><br><span class="line">&gt; <span class="number">12</span> 非零的负整数：^\-[<span class="number">1</span><span class="number">-9</span>][]<span class="number">0</span><span class="number">-9</span><span class="string">"*$ 或 ^-[1-9]\d*$</span></span><br><span class="line"><span class="string">&gt; 13 非负整数：^\d+$ 或 ^[1-9]\d*|0$</span></span><br><span class="line"><span class="string">&gt; 14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</span></span><br><span class="line"><span class="string">&gt; 15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</span></span><br><span class="line"><span class="string">&gt; 16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</span></span><br><span class="line"><span class="string">&gt; 17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span></span><br><span class="line"><span class="string">&gt; 18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span></span><br><span class="line"><span class="string">&gt; 19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span></span><br><span class="line"><span class="string">&gt; </span></span><br><span class="line"><span class="string">&gt; 二、校验字符的表达式</span></span><br><span class="line"><span class="string">&gt; 1 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$</span></span><br><span class="line"><span class="string">&gt; 2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</span></span><br><span class="line"><span class="string">&gt; 3 长度为3-20的所有字符：^.&#123;3,20&#125;$</span></span><br><span class="line"><span class="string">&gt; 4 由26个英文字母组成的字符串：^[A-Za-z]+$</span></span><br><span class="line"><span class="string">&gt; 5 由26个大写英文字母组成的字符串：^[A-Z]+$</span></span><br><span class="line"><span class="string">&gt; 6 由26个小写英文字母组成的字符串：^[a-z]+$</span></span><br><span class="line"><span class="string">&gt; 7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</span></span><br><span class="line"><span class="string">&gt; 8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$</span></span><br><span class="line"><span class="string">&gt; 9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</span></span><br><span class="line"><span class="string">&gt; 10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</span></span><br><span class="line"><span class="string">&gt; 11 可以输入含有^%&amp;',;=?$\"等字符：[^%&amp;',;=?$\x22]+</span></span><br><span class="line"><span class="string">&gt; 12 禁止输入含有~的字符：[^~\x22]+</span></span><br><span class="line"><span class="string">&gt; </span></span><br><span class="line"><span class="string">&gt; 三、特殊需求表达式</span></span><br><span class="line"><span class="string">&gt; 1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span></span><br><span class="line"><span class="string">&gt; </span></span><br><span class="line"><span class="string">&gt; 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span></span><br><span class="line"><span class="string">&gt;     </span></span><br><span class="line"><span class="string">&gt; 3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span></span><br><span class="line"><span class="string">&gt; </span></span><br><span class="line"><span class="string">&gt; 4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</span></span><br><span class="line"><span class="string">&gt; </span></span><br><span class="line"><span class="string">&gt; 5 电话号码("</span>XXX-XXXXXXX<span class="string">"、"</span>XXXX-XXXXXXXX<span class="string">"、"</span>XXX-XXXXXXX<span class="string">"、"</span>XXX-XXXXXXXX<span class="string">"、"</span>XXXXXXX<span class="string">"和"</span>XXXXXXXX)：^(\(\d&#123;<span class="number">3</span>,<span class="number">4</span>&#125;-)|\d&#123;<span class="number">3.4</span>&#125;-)?\d&#123;<span class="number">7</span>,<span class="number">8</span>&#125;$</span><br><span class="line">&gt;        </span><br><span class="line">&gt; <span class="number">6</span> 国内电话号码(<span class="number">0511</span><span class="number">-4405222</span>、<span class="number">021</span><span class="number">-87888822</span>)：\d&#123;<span class="number">3</span>&#125;-\d&#123;<span class="number">8</span>&#125;|\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">7</span>&#125;</span><br><span class="line">&gt;               </span><br><span class="line">&gt; <span class="number">7</span> 身份证号(<span class="number">15</span>位、<span class="number">18</span>位数字)：^\d&#123;<span class="number">15</span>&#125;|\d&#123;<span class="number">18</span>&#125;$</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">8</span> 短身份证号码(数字、字母x结尾)：^([<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">7</span>,<span class="number">18</span>&#125;(x|X)?$ 或 ^\d&#123;<span class="number">8</span>,<span class="number">18</span>&#125;|[<span class="number">0</span><span class="number">-9</span>x]&#123;<span class="number">8</span>,<span class="number">18</span>&#125;|[<span class="number">0</span><span class="number">-9</span>X]&#123;<span class="number">8</span>,<span class="number">18</span>&#125;?$</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">9</span> 帐号是否合法(字母开头，允许<span class="number">5</span><span class="number">-16</span>字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0<span class="number">-9</span>_]&#123;<span class="number">4</span>,<span class="number">15</span>&#125;$</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">10</span> 密码(以字母开头，长度在<span class="number">6</span>~<span class="number">18</span>之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;<span class="number">5</span>,<span class="number">17</span>&#125;$</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">11</span> 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在<span class="number">8</span><span class="number">-10</span>之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;<span class="number">8</span>,<span class="number">10</span>&#125;$</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">12</span> 日期格式：^\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">13</span> 一年的<span class="number">12</span>个月(<span class="number">01</span>～<span class="number">09</span>和<span class="number">1</span>～<span class="number">12</span>)：^(<span class="number">0</span>?[<span class="number">1</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>])$</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">14</span> 一个月的<span class="number">31</span>天(<span class="number">01</span>～<span class="number">09</span>和<span class="number">1</span>～<span class="number">31</span>)：^((<span class="number">0</span>?[<span class="number">1</span><span class="number">-9</span>])|((<span class="number">1</span>|<span class="number">2</span>)[<span class="number">0</span><span class="number">-9</span>])|<span class="number">30</span>|<span class="number">31</span>)$</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">15</span> 钱的输入格式：</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="number">1.</span>有四种钱的表示形式我们可以接受:<span class="string">"10000.00"</span> 和 <span class="string">"10,000.00"</span>, 和没有 <span class="string">"分"</span> 的 <span class="string">"10000"</span> 和 <span class="string">"10,000"</span>：^[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*$</span><br><span class="line">&gt;               </span><br><span class="line">&gt;     <span class="number">2.</span>这表示任意一个不以<span class="number">0</span>开头的数字,但是,这也意味着一个字符<span class="string">"0"</span>不通过,所以我们采用下面的形式：^(<span class="number">0</span>|[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)$</span><br><span class="line">&gt;                                                        </span><br><span class="line">&gt;     <span class="number">3.</span>一个<span class="number">0</span>或者一个不以<span class="number">0</span>开头的数字.我们还可以允许开头有一个负号：^(<span class="number">0</span>|-?[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)$</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="number">4.</span>这表示一个<span class="number">0</span>或者一个可能为负的开头不为<span class="number">0</span>的数字.让用户以<span class="number">0</span>开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]+)?$</span><br><span class="line">&gt;               </span><br><span class="line">&gt;     <span class="number">5.</span>必须说明的是,小数点后面至少应该有<span class="number">1</span>位数,所以<span class="string">"10."</span>是不通过的,但是 <span class="string">"10"</span> 和 <span class="string">"10.2"</span> 是通过的：^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;)?$</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="number">6.</span>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="number">7.</span>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(,[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">3</span>&#125;)*(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="number">8.1</span>到<span class="number">3</span>个数字,后面跟着任意个 逗号+<span class="number">3</span>个数字,逗号成为可选,而不是必须：^([<span class="number">0</span><span class="number">-9</span>]+|[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(,[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">3</span>&#125;)*)(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line">&gt;     </span><br><span class="line">&gt; 备注：这就是最终结果了,别忘了<span class="string">"+"</span>可以用<span class="string">"*"</span>替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span><br><span class="line">&gt;     </span><br><span class="line">&gt; xml文件：^([a-zA-Z]+-?)+[a-zA-Z0<span class="number">-9</span>]+\\.[x|X][m|M][l|L]$</span><br><span class="line">&gt;     </span><br><span class="line">&gt; 中文字符的正则表达式：[\u4e00-\u9fa5]</span><br><span class="line">&gt;     </span><br><span class="line">&gt; 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计<span class="number">2</span>，ASCII字符计<span class="number">1</span>))</span><br><span class="line">&gt;     </span><br><span class="line">&gt; 空白行的正则表达式：\n\s*\r (可以用来删除空白行)</span><br><span class="line">&gt;     </span><br><span class="line">&gt; HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?<span class="xml"><span class="tag">&lt;/<span class="name">\1</span>&gt;</span></span>|<span class="xml"><span class="tag">&lt;<span class="name">.*?</span> /&gt;</span> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span></span><br><span class="line"><span class="xml">&gt;     </span></span><br><span class="line"><span class="xml">&gt; 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span></span><br><span class="line"><span class="xml">&gt;     </span></span><br><span class="line"><span class="xml">&gt; 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)</span></span><br><span class="line"><span class="xml">&gt;     </span></span><br><span class="line"><span class="xml">&gt; 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)</span></span><br><span class="line"><span class="xml">&gt;     </span></span><br><span class="line"><span class="xml">&gt; IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)</span></span><br><span class="line"><span class="xml">&gt; </span></span><br><span class="line"><span class="xml">&gt; IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</span></span><br><span class="line"><span class="xml">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="MVVM及实现原理"><a href="#MVVM及实现原理" class="headerlink" title="MVVM及实现原理"></a>MVVM及实现原理</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; MVVM和MVC的区别</span><br><span class="line">&gt; </span><br><span class="line">&gt;     MVC和MVVM的区别其实并不大。都是一种设计思想。</span><br><span class="line">&gt;     主要就是MVC中Controller演变成MVVM中的viewModel。</span><br><span class="line">&gt;     MVVM主要解决了MVC中大量的DOM操作使页面渲染性能降低，加载速度变慢，影响用户体验。</span><br><span class="line">&gt;     当和Model频繁发生变化，开发者需要主动更新到View。</span><br><span class="line">&gt; </span><br><span class="line">&gt; MVVM：是Model-View-ViewModel的简写</span><br><span class="line">&gt; </span><br><span class="line">&gt;     M：对应于MVC的M</span><br><span class="line">&gt;     V：对应于MVC的V</span><br><span class="line">&gt;     VM：ViewModel，是把MVC里的controller的数据加载，加工功能分离出来</span><br><span class="line">&gt; </span><br><span class="line">&gt; MVVM是Web前端一种非常流行的开发模式，</span><br><span class="line">&gt; 利用MVVM可以使我们的代码更加专注于处理业务逻辑而不是去关心DOM操作。</span><br><span class="line">&gt; 目前著名的MVVM框架有VUE，avalon，angular等</span><br><span class="line">&gt; </span><br><span class="line">&gt; MVVM设计模式的优点</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="number">1.</span>  双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化。很好的做到数据的一致性</span><br><span class="line">&gt;     <span class="number">2.</span>  由于控制器的功能大都移动到View上处理，大大的对控制器进行了瘦身</span><br><span class="line">&gt;     <span class="number">3.</span>  View的功能进一步强化，具有控制的部分功能，</span><br><span class="line">&gt;          若想无限增强它的功能，甚至控制器的全部功能几乎都可以迁移到各个View上</span><br><span class="line">&gt;      	（不过这样不可取，那样View干不了属于它职责范围内的事情）。</span><br><span class="line">&gt;         View可以像控制器一样具有自己都View-Model</span><br><span class="line">&gt;     <span class="number">4.</span>  可以对View或ViewController的数据处理部分抽象出来一个函数处理model。 </span><br><span class="line">&gt;           这样它们专职页面布局和页面跳转，它们必然更一步的简化。</span><br><span class="line">&gt;       </span><br><span class="line">&gt; MVVM设计模式的缺点</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="number">1.</span>  数据绑定也使得bug很难被调试。比如你看到页面异常了，有可能是你的View的代码有bug，也可能是你的model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</span><br><span class="line">&gt;     <span class="number">2.</span>  数据双向绑定不利于代码重用。客户端开发最常用的是View，但是数据双向绑定技术，让你在一个View都绑定了一个model，不同的模块model都不同。那就不能简单重用view了</span><br><span class="line">&gt;     <span class="number">3.</span>  一个大的模块中model也会很大，虽然使用方便了也很容易保证数据的一致性，但是长期持有，不释放内存就造成话费更多的内存。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>原理</code></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; MVVM的实现主要是三个核心点：</span><br><span class="line">&gt;     响应式：vue如何监听data的属性变化</span><br><span class="line">&gt;     模板解析：vue的模板是如何被解析的</span><br><span class="line">&gt;     渲染：vue模板是如何被渲染成HTML的	</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就拿到最新值并通知订阅者。</span><br><span class="line">&gt;     实现一个订阅者Watcher，连接Observer和Compile。可以订阅并收到每个属性的变化通知并执行指令绑定的相应函数，从而更新视图。</span><br><span class="line">&gt;     实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板替换数据，以及绑定相应的更新函数。</span><br><span class="line">&gt;     mvvm入口函数，整合以上三者。</span><br><span class="line">&gt;     </span><br><span class="line">&gt;      <span class="number">1</span>）发布者-订阅者模式: 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(<span class="string">'property'</span>, value)。</span><br><span class="line">&gt;     （<span class="number">2</span>）脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，在指定的事件触发时进入脏值检测。</span><br><span class="line">&gt;     （<span class="number">3</span>）数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过<span class="built_in">Object</span>.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; webpack是目前前端开发中最流行的打包工具，不仅能实现 JS 打包，还能将 CSS 文件，图片文件，甚至是 LESS 文件打包，每一个文件都是一个独立的模块，并且实现按需加载。使用时需要安装 webpack 、 webpack-cli 、webpack-dev-server三个基础模块。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 配置参数说明 :</span><br><span class="line">&gt; </span><br><span class="line">&gt;     mode：两种 mode 模式可供选择，一种是开发环境，命令为 webpack --mode = development，打包出来的文件未经过压缩；一种是生产环境，命令是 webpack --mode = production ，打包出来的文件是经过压缩的。</span><br><span class="line">&gt;     entry：资源入口文件，所有的资源最后会打包成一个 JS 文件。</span><br><span class="line">&gt;     ouput：打包之后存放的文件路径。path 为相对路径，filename 为打包后的文件名。</span><br><span class="line">&gt;     <span class="built_in">module</span>：rules 配置编译规则，test 正则匹配，exclude 排除特定条件，use-loader，test 匹配到的解析器模块，use-options，与use-loader配合使用。</span><br><span class="line">&gt;     plugins：插件。plugins 与 loader 的区别在于，loader 只是一个解析模块，比如将 ES5 解析成 ES6，LESS 文件解析成 CSS 文件，为了兼容浏览器。而 plugins 是将 loader 之后的文件进行优化分类、压缩、提供公共代码等。</span><br><span class="line">&gt;     devServer：服务器配置，contentBase 文件路径，compress 是否启动 gzip 压缩，host 主机地址，port 端口号，publicPath。</span><br><span class="line">&gt;     </span><br><span class="line">&gt; 常用 plugins :</span><br><span class="line">&gt;     <span class="number">1.</span> extract-text-webpack-plugin 与 mini-css-extract-plugin</span><br><span class="line">&gt;         分离 .css 分解，后者需要 webpack <span class="number">4.2</span><span class="number">.0</span> 版本以上。</span><br><span class="line">&gt;     <span class="number">2.</span> UglifyJsPlugin</span><br><span class="line">&gt;         压缩 js 文件，减小 js 文件。</span><br><span class="line">&gt;     <span class="number">3.</span> html-webpack-plugin 与 html-loader</span><br><span class="line">&gt;         生成 html 文件。</span><br><span class="line">&gt;     <span class="number">4.</span> clean-webpack-plugin	</span><br><span class="line">&gt;         每次构建之前清理历史打包文件.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt; 　　<span class="number">1.</span>Node 是一个服务器端 JavaScript 解释器，可是真的以为JavaScript不错的同学学习Node就能轻松拿下，那么你就错了，总结：水深不深我还不知道，不过确实不浅。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 　　<span class="number">2.</span>Node 的目标是帮助程序员构建高度可伸缩的应用程序，编写能够处理数万条同时连接到一个物理机的连接代码。处理高并发和异步I/O是Node受到开发人员的关注的原因之一。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 　　<span class="number">3.</span>Node 本身运行Google V8 JavaScript引擎，所以速度和性能非常好，看chrome就知道，而且Node对其封装的同时还改进了其处理二进制数据的能力。因此，Node不仅仅简单的使用了V8，还对其进行了优化，使其在各种环境下更加给力。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 　　<span class="number">4.</span>第三方的扩展和模块在Node的使用中起到重要的作用。</span><br><span class="line">&gt;   </span><br><span class="line">&gt; 什么是nodejs</span><br><span class="line">&gt;     nodejs 就是JavaScript的运行环境</span><br><span class="line">&gt; </span><br><span class="line">&gt; 为什么会有nodejs</span><br><span class="line">&gt;     因为需要</span><br><span class="line">&gt;     需要JavaScript这个语言运行在服务器上</span><br><span class="line">&gt;     node 是一个运行环境 是一个平台 开始是由一个人设计的</span><br><span class="line">&gt;     node选择了js 而不是js发展出的node</span><br><span class="line">&gt;     设计了一个平台 用于运行js</span><br><span class="line">&gt;     node环境是跨平台的</span><br><span class="line">&gt;     node运行在服务端 没有DOM BOM</span><br><span class="line">&gt; </span><br><span class="line">&gt; node的组成</span><br><span class="line">&gt;     ecmascript libuv</span><br><span class="line">&gt;     基于v8引擎</span><br><span class="line">&gt; </span><br><span class="line">&gt; REPL环境</span><br><span class="line">&gt;     Read - Eval - Print - Loop</span><br><span class="line">&gt;     退出REPL Ctrl+C 连按两次 | .exit</span><br><span class="line">&gt; </span><br><span class="line">&gt; node环境的全局对象</span><br><span class="line">&gt;     global</span><br><span class="line">&gt; </span><br><span class="line">&gt; nodejs概念</span><br><span class="line">&gt;     nodejs是建立在谷歌v8引擎上的javascript运行环境</span><br><span class="line">&gt;     nodejs基于非阻塞I/O模型</span><br><span class="line">&gt;     Input/Output 都是阻塞操作</span><br><span class="line">&gt;     用户的输入都是无状态的 所以都是阻塞操作</span><br><span class="line">&gt;     nodejs 它的运行环境是单线程</span><br><span class="line">&gt;     nodejs 处理阻塞操作 通过的是 异步（回调）</span><br><span class="line">&gt;     单线程(主线程)主要来处理业务逻辑 执行js</span><br><span class="line">&gt;     遇到阻塞操作 将阻塞操作提出 放入 事件队列(Event Loop)</span><br><span class="line">&gt;     nodejs 优势 处理高并发能</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="BFC-产生BFC-浮动，清除浮动"><a href="#BFC-产生BFC-浮动，清除浮动" class="headerlink" title="BFC,产生BFC,浮动，清除浮动"></a>BFC,产生BFC,浮动，清除浮动</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; 一、什么是BFC？IFC?</span><br><span class="line">&gt; </span><br><span class="line">&gt;     BFC（Block Formatting Context）即“块级格式化上下文”， IFC（Inline Formatting Context）即行内格式化上下文。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态。一个框在常规流中必须属于一个格式化上下文，你可以把BFC想象成一个大箱子，箱子外边的元素将不与箱子内的元素产生作用。</span><br><span class="line">&gt; </span><br><span class="line">&gt;     BFC是W3C CSS <span class="number">2.1</span> 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC就是一个作用范围。在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 blockformatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 InlineFormatting Context(行内格式化上下文) 里格式化。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 二、BFC的特性是什么？</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="number">1</span>、BFC会阻止外边距叠加：一般情况，两个相邻的块级框，它们之间的垂直方向的外边距会发生叠加。 如果这</span><br><span class="line">&gt; 两个相邻的块框不属于同一个BFC就不会叠加！</span><br><span class="line">&gt; BFC不会重叠浮动元素</span><br><span class="line">&gt;     <span class="number">2</span>、一个BFC的边框不能和它里面的元素的margin重叠。这意味着浏览器将会给BFC创建隐式的外边距来阻止它和浮动元素的外边距的叠加。当给一个挨着浮动的BFC添加负得外边距不会起作用！</span><br><span class="line">&gt; 三、如何触发BFC?</span><br><span class="line">&gt; </span><br><span class="line">&gt;     float除了none以外的值</span><br><span class="line">&gt;     overflow除了visible之外的值</span><br><span class="line">&gt;     display(table-cell table-caption,inline-block)</span><br><span class="line">&gt;     position(absolute,fixed)</span><br><span class="line">&gt; </span><br><span class="line">&gt; 四、如何清除浮动</span><br><span class="line">&gt; </span><br><span class="line">&gt;     css 浮动后的元素不论是什么display的都默认是block就是设置inline也是block</span><br><span class="line">&gt; </span><br><span class="line">&gt;     方式一:使用overflow属性来清除浮动.ovh&#123;<span class="attr">overflow</span>:hidden;&#125;</span><br><span class="line">&gt;         先找到浮动盒子的父元素，再在父元素中添加一个属性：overflow:hidden,就是清除这个父元素中的子元素浮动对页面的影响.</span><br><span class="line">&gt;         注意：一般情况下也不会使用这种方式，因为overflow:hidden有一个特点，离开了这个元素所在的区域以后会被隐藏（overflow:hidden会将超出的部分隐藏起来）.</span><br><span class="line">&gt;     方式二:使用额外标签法.clear&#123;<span class="attr">clear</span>:both;&#125;</span><br><span class="line">&gt;         在浮动的盒子之下再放一个标签，在这个标签中使用clear:both，来清除浮动对页面的影响.</span><br><span class="line">&gt;         a.内部标签：会将这个浮动盒子的父盒子高度重新撑开</span><br><span class="line">&gt; </span><br><span class="line">&gt;         b.外部标签：会将这个浮动盒子的影响清除，但是不会撑开父盒子.</span><br><span class="line">&gt;         注意：一般情况下不会使用这一种方式来清除浮动。因为这种清除浮动的方式会增加页面的标签，造成结构的混乱.</span><br><span class="line">&gt;     方法三:使用伪元素来清除浮动(after意思:后来,以后)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h1><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 伪类其实是弥补了CSS选择器的不足，用来更方便地获取信息</span><br><span class="line">&gt; </span><br><span class="line">&gt; 而伪元素本质上是创建了一个虚拟容器(元素)，我们可以在其中添加内容或样式。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 所以，你可以理解伪元素本质上是创建了一个虚拟容器(元素)了吧。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 除了上面这个本质区别以外，在CSS3中，伪类用单冒号:表示；而伪元素用双冒号::表示。一个选择器可以同时使用多个伪类(但有的伪类会互斥)；而一个选择器只能同时使用一个伪元素(未来的版本可能会支持多伪元素)。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>#实现instanceof</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">var</span> proto = left.__proto__;</span><br><span class="line">&gt;     <span class="keyword">var</span> protoType = right.prototype;</span><br><span class="line">&gt;     <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">&gt;         <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">if</span> (proto == protoType) &#123;</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         proto = proto.__proto__</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>#lazyMan</p>
<p>原题如下：</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; 实现一个LazyMan，可以按照以下方式调用:</span><br><span class="line">&gt; LazyMan(<span class="string">"Hank"</span>)输出:</span><br><span class="line">&gt; Hi! This is Hank!</span><br><span class="line">&gt;  </span><br><span class="line">&gt; LazyMan(<span class="string">"Hank"</span>).sleep(<span class="number">10</span>).eat(<span class="string">"dinner"</span>)输出</span><br><span class="line">&gt; Hi! This is Hank!</span><br><span class="line">&gt; <span class="comment">//等待10秒..</span></span><br><span class="line">&gt; Wake up after <span class="number">10</span></span><br><span class="line">&gt; Eat dinner~</span><br><span class="line">&gt;  </span><br><span class="line">&gt; LazyMan(<span class="string">"Hank"</span>).eat(<span class="string">"dinner"</span>).eat(<span class="string">"supper"</span>)输出</span><br><span class="line">&gt; Hi This is Hank!</span><br><span class="line">&gt; Eat dinner~</span><br><span class="line">&gt; Eat supper~</span><br><span class="line">&gt;  </span><br><span class="line">&gt; LazyMan(<span class="string">"Hank"</span>).sleepFirst(<span class="number">5</span>).eat(<span class="string">"supper"</span>)输出</span><br><span class="line">&gt; <span class="comment">//等待5秒</span></span><br><span class="line">&gt; Wake up after <span class="number">5</span></span><br><span class="line">&gt; Hi This is Hank!</span><br><span class="line">&gt; Eat supper</span><br><span class="line">&gt;  </span><br><span class="line">&gt; 以此类推。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这道题主要考察的是链式调用、任务队列、流程控制等。关键是用手动调用next函数来进行下次事件的调用，类似<code>express</code>中间件和<code>vue-router</code>路由的执行过程。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">_LazyMan</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">this</span>.nama = name;</span><br><span class="line">&gt;     <span class="keyword">this</span>.queue = [];</span><br><span class="line">&gt;     <span class="keyword">this</span>.queue.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">&gt;         <span class="built_in">console</span>.log(<span class="string">"Hi! This is "</span> + name + <span class="string">"!"</span>);</span><br><span class="line">&gt;         <span class="keyword">this</span>.next();</span><br><span class="line">&gt;     &#125;)</span><br><span class="line">&gt;     setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.next()</span><br><span class="line">&gt;     &#125;,<span class="number">0</span>)</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   _LazyMan.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">this</span>.queue.push(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">&gt;         <span class="built_in">console</span>.log(<span class="string">"Eat "</span> + name + <span class="string">"~"</span>);</span><br><span class="line">&gt;         <span class="keyword">this</span>.next()</span><br><span class="line">&gt;     &#125;)</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   _LazyMan.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">var</span> fn = <span class="keyword">this</span>.queue.shift();</span><br><span class="line">&gt;     fn &amp;&amp; fn();</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   _LazyMan.prototype.sleep = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">this</span>.queue.push(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">&gt;         setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(<span class="string">"Wake up after "</span> + time + <span class="string">"s!"</span>);</span><br><span class="line">&gt;             <span class="keyword">this</span>.next()</span><br><span class="line">&gt;         &#125;,time * <span class="number">1000</span>)</span><br><span class="line">&gt;     &#125;)</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   _LazyMan.prototype.sleepFirst = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">this</span>.queue.unshift(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">&gt;         setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(<span class="string">"Wake up after "</span> + time + <span class="string">"s!"</span>);</span><br><span class="line">&gt;             <span class="keyword">this</span>.next()</span><br><span class="line">&gt;         &#125;,time * <span class="number">1000</span>)</span><br><span class="line">&gt;     &#125;)</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">LazyMan</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">new</span> _LazyMan(name)</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><p>函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术，是高阶函数的一种用法。比如求和函数<code>add(1,2,3)</code>, 经过柯里化后变成<code>add(1)(2)(3)</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; function currying(fn,...args)&#123;</span><br><span class="line">&gt;     if(fn.length &lt;= args.length)&#123;</span><br><span class="line">&gt;         return fn(...args)</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     return function(...args1)&#123;</span><br><span class="line">&gt;         return currying(fn,...args,...args1)</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; function add(a,b,c)&#123;</span><br><span class="line">&gt;     return a + b + c</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; add(1,2,3) // 6</span><br><span class="line">&gt; var curryingAdd = currying(add);</span><br><span class="line">&gt; curryingAdd(1)(2)(3) // 6</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>#sleep函数</p>
<p><code>sleep</code> 函数的作用就是延迟指定时间后再执行接下来的函数。用 <code>promise</code> 很好实现。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;         setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">&gt;             resolve(<span class="literal">true</span>);</span><br><span class="line">&gt;         &#125;, time*<span class="number">1000</span>);</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>#实现Promise.all</p>
<p><code>Promise.all</code> 需要等到所有的 <code>promise</code> 的状态都变成 <code>fulfilled</code> 之后才 <code>resolve</code>, 但只要有一个 <code>promise</code> 失败即返回失败的结果。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;         <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(arr))&#123;</span><br><span class="line">&gt;             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`argument must be a array`</span>)</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">var</span> length = arr.length;</span><br><span class="line">&gt;         <span class="keyword">var</span> resolveNum = <span class="number">0</span>;</span><br><span class="line">&gt;         <span class="keyword">var</span> resolveResult = [];</span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">&gt;             arr[i].then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">&gt;                 resolveNum++;</span><br><span class="line">&gt;                 resolveResult.push(data)</span><br><span class="line">&gt;                 <span class="keyword">if</span>(resolveNum == length)&#123;</span><br><span class="line">&gt;                     <span class="keyword">return</span> resolve(resolveResult)</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;             &#125;).catch(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">&gt;                 <span class="keyword">return</span> reject(data)</span><br><span class="line">&gt;             &#125;)</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;)</span><br><span class="line">&gt;     </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>#promise.retry</p>
<p><code>promise.retry</code> 的作用是执行一个函数，如果不成功最多可以尝试 times 次。传参需要三个变量，所要执行的函数，尝试的次数以及延迟的时间。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Promise</span>.retry = <span class="function"><span class="keyword">function</span>(<span class="params">fn, times, delay</span>) </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">&gt;         <span class="keyword">var</span> error;</span><br><span class="line">&gt;         <span class="keyword">var</span> attempt = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;             <span class="keyword">if</span> (times == <span class="number">0</span>) &#123;</span><br><span class="line">&gt;                 reject(error);</span><br><span class="line">&gt;             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;                 fn().then(resolve)</span><br><span class="line">&gt;                     .catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&gt;                         times--;</span><br><span class="line">&gt;                         error = e;</span><br><span class="line">&gt;                         setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;attempt()&#125;, delay);</span><br><span class="line">&gt;                     &#125;);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;;</span><br><span class="line">&gt;         attempt();</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>#将一个同步callback包装成promise形式</p>
<p>同步的 callback 用的最多的是在 node 的回调中，例如下面这种，包装完之后就可以愉快的使用 <code>.then</code> 了。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;   nodeGet(param, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123; &#125;)</span><br><span class="line">&gt;   <span class="comment">// 转化成promise形式</span></span><br><span class="line">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">nodeGetAysnc</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;       nodeGet(param, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span> (err !== <span class="literal">null</span>) <span class="keyword">return</span> reject(err)</span><br><span class="line">&gt;         resolve(data)</span><br><span class="line">&gt;       &#125;)</span><br><span class="line">&gt;   &#125;)&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>按照上面的思路，即可写出通用版的形式。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">fn,context</span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;         fn.apply(context,[...args,(err,res) =&gt; &#123;</span><br><span class="line">&gt;             <span class="keyword">return</span> err ? reject(err) : resolve(res)</span><br><span class="line">&gt;         &#125;])</span><br><span class="line">&gt;     &#125;)</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>#写一个函数，可以控制最大并发数</p>
<p>微信小程序最一开始对并发数限制为5个，后来升级到10个，如果超过10个会被舍弃。后来微信小程序升级为不限制并发请求，但超过10个会排队机制。也就是当同时调用的请求超过 10 个时，小程序会先发起 10 个并发请求，超过 10 个的部分按调用顺序进行排队，当前一个请求完成时，再发送队列中的下一个请求。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">concurrentPoll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">this</span>.tasks = [];</span><br><span class="line">&gt;     <span class="keyword">this</span>.max = <span class="number">10</span>;</span><br><span class="line">&gt;     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.run()</span><br><span class="line">&gt;     &#125;,<span class="number">0</span>)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; concurrentPoll.prototype.addTask = <span class="function"><span class="keyword">function</span>(<span class="params">task</span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; concurrentPoll.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">if</span>(<span class="keyword">this</span>.tasks.length == <span class="number">0</span>)&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">var</span> min = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.tasks.length, max);</span><br><span class="line">&gt;     <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; min; i++)&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.max--;</span><br><span class="line">&gt;         <span class="keyword">var</span> task = <span class="keyword">this</span>.tasks.shift();</span><br><span class="line">&gt;         task().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(res)</span><br><span class="line">&gt;         &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(err)</span><br><span class="line">&gt;         &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">&gt;             <span class="keyword">this</span>.max++;</span><br><span class="line">&gt;             <span class="keyword">this</span>.run();</span><br><span class="line">&gt;         &#125;)</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>

      
      <!-- 打赏 -->
      
        <div id="reward-btn">
          打赏
        </div>
        
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/25/随记/" data-id="ck55ikzdn000c6wcwebqks7xr"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  
  
  <nav class="article-nav">
    
    
      <a href="/2019/12/13/login/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">login</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: false,
        app_id: 'chaSYi8FMdJBwzIBpxeNjqWC-gzGzoHsz',
        app_key: 'PqqkLYgPkHvH1BmyQqySWnSK',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        John Doe
      </li>
      <li>
        
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a> by shenyu
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <ul class="list-inline">
  <li>PV:<span id="busuanzi_value_page_pv"></span></li>
  <li>UV:<span id="busuanzi_value_site_uv"></span></li>
</ul>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    
    <aside class="sidebar">
      
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="空欢"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/旅行/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  </div>
</body>

</html>